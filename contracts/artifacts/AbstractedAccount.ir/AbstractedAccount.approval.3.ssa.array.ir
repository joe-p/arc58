main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        goto block@1
    block@1: // L168
        let tmp%0#1: uint64 = (txn NumAppArgs)
        let tmp%1#0: bool = (!= tmp%0#1 0u)
        goto tmp%1#0 ? block@2 : block@18
    block@2: // abi_routing_L168
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "createApplication(address,address)void" => block@3, method "arc58_changeAdmin(address)void" => block@4, method "arc58_pluginChangeAdmin(uint64,address,address)void" => block@5, method "arc58_getAdmin()address" => block@6, method "arc58_verifyAuthAddr()void" => block@7, method "arc58_rekeyTo(address,bool)void" => block@8, method "arc58_canCall(uint64,bool,address,byte[4])bool" => block@9, method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void" => block@10, method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void" => block@11, method "arc58_addPlugin(uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@12, method "arc58_removePlugin(uint64,address)void" => block@13, method "arc58_addNamedPlugin(string,uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@14, method "arc58_removeNamedPlugin(string)void" => block@15, * => block@16}
    block@3: // createApplication_route_L576
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (== tmp%3#0 NoOp)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (== tmp%5#0 0u)
        (assert tmp%6#0) // can only call when creating
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 2)
        contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0: bool = 1u
        goto block@20
    block@4: // arc58_changeAdmin_route_L596
        let tmp%7#0: uint64 = (txn OnCompletion)
        let tmp%8#0: bool = (== tmp%7#0 NoOp)
        (assert tmp%8#0) // OnCompletion is not NoOp
        let tmp%9#0: uint64 = (txn ApplicationID)
        let tmp%10#0: bool = (!= tmp%9#0 0u)
        (assert tmp%10#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(reinterpret_bytes[32]%2#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1: bool = 1u
        goto block@20
    block@5: // arc58_pluginChangeAdmin_route_L611
        let tmp%11#0: uint64 = (txn OnCompletion)
        let tmp%12#0: bool = (== tmp%11#0 NoOp)
        (assert tmp%12#0) // OnCompletion is not NoOp
        let tmp%13#0: uint64 = (txn ApplicationID)
        let tmp%14#0: bool = (!= tmp%13#0 0u)
        (assert tmp%14#0) // can only call when not creating
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 1)
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%4#0: bytes[32] = (txna ApplicationArgs 3)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(reinterpret_bytes[8]%0#0, reinterpret_bytes[32]%3#0, reinterpret_bytes[32]%4#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2: bool = 1u
        goto block@20
    block@6: // arc58_getAdmin_route_L641
        let tmp%15#0: uint64 = (txn OnCompletion)
        let tmp%16#0: bool = (== tmp%15#0 NoOp)
        (assert tmp%16#0) // OnCompletion is not NoOp
        let tmp%17#0: uint64 = (txn ApplicationID)
        let tmp%18#0: bool = (!= tmp%17#0 0u)
        (assert tmp%18#0) // can only call when not creating
        let tmp%19#0: bytes[32] = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin()
        let tmp%20#0: bytes = (concat 0x151f7c75 tmp%19#0)
        (log tmp%20#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3: bool = 1u
        goto block@20
    block@7: // arc58_verifyAuthAddr_route_L649
        let tmp%21#0: uint64 = (txn OnCompletion)
        let tmp%22#0: bool = (== tmp%21#0 NoOp)
        (assert tmp%22#0) // OnCompletion is not NoOp
        let tmp%23#0: uint64 = (txn ApplicationID)
        let tmp%24#0: bool = (!= tmp%23#0 0u)
        (assert tmp%24#0) // can only call when not creating
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr()
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4: bool = 1u
        goto block@20
    block@8: // arc58_rekeyTo_route_L660
        let tmp%25#0: uint64 = (txn OnCompletion)
        let tmp%26#0: bool = (== tmp%25#0 NoOp)
        (assert tmp%26#0) // OnCompletion is not NoOp
        let tmp%27#0: uint64 = (txn ApplicationID)
        let tmp%28#0: bool = (!= tmp%27#0 0u)
        (assert tmp%28#0) // can only call when not creating
        let reinterpret_bytes[32]%5#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(reinterpret_bytes[32]%5#0, reinterpret_bytes[1]%0#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5: bool = 1u
        goto block@20
    block@9: // arc58_canCall_route_L686
        let tmp%29#0: uint64 = (txn OnCompletion)
        let tmp%30#0: bool = (== tmp%29#0 NoOp)
        (assert tmp%30#0) // OnCompletion is not NoOp
        let tmp%31#0: uint64 = (txn ApplicationID)
        let tmp%32#0: bool = (!= tmp%31#0 0u)
        (assert tmp%32#0) // can only call when not creating
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%33#0: bool = (getbit reinterpret_bytes[1]%1#0 0u)
        let reinterpret_bytes[32]%6#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[4]%0#0: bytes[4] = (txna ApplicationArgs 4)
        let to_encode%0#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(reinterpret_bytes[8]%1#0, tmp%33#0, reinterpret_bytes[32]%6#0, reinterpret_bytes[4]%0#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%34#0: bytes = (concat 0x151f7c75 encoded_bool%0#0)
        (log tmp%34#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6: bool = 1u
        goto block@20
    block@10: // arc58_rekeyToPlugin_route_L708
        let tmp%35#0: uint64 = (txn OnCompletion)
        let tmp%36#0: bool = (== tmp%35#0 NoOp)
        (assert tmp%36#0) // OnCompletion is not NoOp
        let tmp%37#0: uint64 = (txn ApplicationID)
        let tmp%38#0: bool = (!= tmp%37#0 0u)
        (assert tmp%38#0) // can only call when not creating
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%39#0: bool = (getbit reinterpret_bytes[1]%2#0 0u)
        let tmp%40#0: bytes = (txna ApplicationArgs 3)
        let tmp%41#0: bytes = (txna ApplicationArgs 4)
        let (arc58_rekeyToPlugin%0#0: bytes, arc58_rekeyToPlugin%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(reinterpret_bytes[8]%2#0, tmp%39#0, tmp%40#0, tmp%41#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7: bool = 1u
        goto block@20
    block@11: // arc58_rekeyToNamedPlugin_route_L757
        let tmp%42#0: uint64 = (txn OnCompletion)
        let tmp%43#0: bool = (== tmp%42#0 NoOp)
        (assert tmp%43#0) // OnCompletion is not NoOp
        let tmp%44#0: uint64 = (txn ApplicationID)
        let tmp%45#0: bool = (!= tmp%44#0 0u)
        (assert tmp%45#0) // can only call when not creating
        let tmp%46#0: bytes = (txna ApplicationArgs 1)
        let tmp%47#0: bytes = ((extract 2 0) tmp%46#0)
        let reinterpret_bytes[1]%3#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%48#0: bool = (getbit reinterpret_bytes[1]%3#0 0u)
        let tmp%49#0: bytes = (txna ApplicationArgs 3)
        let tmp%50#0: bytes = (txna ApplicationArgs 4)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(tmp%47#0, tmp%48#0, tmp%49#0, tmp%50#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8: bool = 1u
        goto block@20
    block@12: // arc58_addPlugin_route_L779
        let tmp%51#0: uint64 = (txn OnCompletion)
        let tmp%52#0: bool = (== tmp%51#0 NoOp)
        (assert tmp%52#0) // OnCompletion is not NoOp
        let tmp%53#0: uint64 = (txn ApplicationID)
        let tmp%54#0: bool = (!= tmp%53#0 0u)
        (assert tmp%54#0) // can only call when not creating
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 1)
        let reinterpret_bytes[32]%7#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[1]%4#0: bytes[1] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%5#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 5)
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%55#0: bytes = (txna ApplicationArgs 7)
        let reinterpret_bytes[1]%6#0: bytes[1] = (txna ApplicationArgs 8)
        let reinterpret_bytes[1]%7#0: bytes[1] = (txna ApplicationArgs 9)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(reinterpret_bytes[8]%3#0, reinterpret_bytes[32]%7#0, reinterpret_bytes[1]%4#0, reinterpret_bytes[1]%5#0, reinterpret_bytes[8]%4#0, reinterpret_bytes[8]%5#0, tmp%55#0, reinterpret_bytes[1]%6#0, reinterpret_bytes[1]%7#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9: bool = 1u
        goto block@20
    block@13: // arc58_removePlugin_route_L850
        let tmp%56#0: uint64 = (txn OnCompletion)
        let tmp%57#0: bool = (== tmp%56#0 NoOp)
        (assert tmp%57#0) // OnCompletion is not NoOp
        let tmp%58#0: uint64 = (txn ApplicationID)
        let tmp%59#0: bool = (!= tmp%58#0 0u)
        (assert tmp%59#0) // can only call when not creating
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 1)
        let reinterpret_bytes[32]%8#0: bytes[32] = (txna ApplicationArgs 2)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(reinterpret_bytes[8]%6#0, reinterpret_bytes[32]%8#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10: bool = 1u
        goto block@20
    block@14: // arc58_addNamedPlugin_route_L875
        let tmp%60#0: uint64 = (txn OnCompletion)
        let tmp%61#0: bool = (== tmp%60#0 NoOp)
        (assert tmp%61#0) // OnCompletion is not NoOp
        let tmp%62#0: uint64 = (txn ApplicationID)
        let tmp%63#0: bool = (!= tmp%62#0 0u)
        (assert tmp%63#0) // can only call when not creating
        let tmp%64#0: bytes = (txna ApplicationArgs 1)
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%9#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%8#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[1]%9#0: bytes[1] = (txna ApplicationArgs 5)
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 6)
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%65#0: bytes = (txna ApplicationArgs 8)
        let reinterpret_bytes[1]%10#0: bytes[1] = (txna ApplicationArgs 9)
        let reinterpret_bytes[1]%11#0: bytes[1] = (txna ApplicationArgs 10)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(tmp%64#0, reinterpret_bytes[8]%7#0, reinterpret_bytes[32]%9#0, reinterpret_bytes[1]%8#0, reinterpret_bytes[1]%9#0, reinterpret_bytes[8]%8#0, reinterpret_bytes[8]%9#0, tmp%65#0, reinterpret_bytes[1]%10#0, reinterpret_bytes[1]%11#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11: bool = 1u
        goto block@20
    block@15: // arc58_removeNamedPlugin_route_L939
        let tmp%66#0: uint64 = (txn OnCompletion)
        let tmp%67#0: bool = (== tmp%66#0 NoOp)
        (assert tmp%67#0) // OnCompletion is not NoOp
        let tmp%68#0: uint64 = (txn ApplicationID)
        let tmp%69#0: bool = (!= tmp%68#0 0u)
        (assert tmp%69#0) // can only call when not creating
        let tmp%70#0: bytes = (txna ApplicationArgs 1)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(tmp%70#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12: bool = 1u
        goto block@20
    block@16: // switch_case_default_L168
        goto block@17
    block@17: // switch_case_next_L168
        goto block@19
    block@18: // bare_routing_L168
        goto block@19
    block@19: // after_if_else_L168
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13: bool = 0u
        goto block@20
    block@20: // after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router___L1
        let tmp%0#0: bool = φ(contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0 <- block@3, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1 <- block@4, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2 <- block@5, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3 <- block@6, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4 <- block@7, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5 <- block@8, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6 <- block@9, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7 <- block@10, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8 <- block@11, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9 <- block@12, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10 <- block@13, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11 <- block@14, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12 <- block@15, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13 <- block@19)
        return tmp%0#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
    block@0: // L200
        let new_state_value%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_user_interaction" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange() -> void:
    block@0: // L204
        let new_state_value%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_change" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(app: bytes[8], caller: bytes[32], method: bytes[4]) -> bool:
    block@0: // L208
        let encoded_tuple_buffer%1#0: bytes = (concat 0x app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 caller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        goto maybe_exists%0#0 ? block@2 : block@1
    block@1: // if_body_L211
        return 0u
    block@2: // after_if_else_L211
        let tmp%1#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%1#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%1#0)
        let tmp%2#0: bytes = (substring3 maybe_value%1#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%2#0
        let methods#0: bytes = copy%0#0
        let tmp%3#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%4#0: bool = (> tmp%3#0 0u)
        let select%0#0: bool = (select 1u 0u tmp%4#0)
        let methodAllowed#0: bool = select%0#0
        let i#0: uint64 = 0u
        goto block@3
    block@3: // while_top_L217
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@6)
        let tmp%5#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@4 : block@7
    block@4: // while_body_L217
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 20u)
        let tmp%7#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let tmp%8#0: bytes = (extract3 tmp%7#0 0u 4u) // on error: Index access is out of bounds
        let tmp%9#0: bool = (== tmp%8#0 method#0)
        goto tmp%9#0 ? block@5 : block@6
    block@5: // if_body_L218
        let methodAllowed#1: bool = 1u
        goto block@8
    block@6: // after_if_else_L218
        let i#2: uint64 = (+ i#1 1u)
        goto block@3
    block@7: // after_while_L217
        goto block@8
    block@8: // L217
        let methodAllowed#4: bool = φ(methodAllowed#1 <- block@5, methodAllowed#0 <- block@7)
        let tmp%10#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%10#0)
        (assert maybe_exists%2#0) // Box must have value
        let copy%1#0: bytes = maybe_value%2#0
        let p#0: bytes = copy%1#0
        let is_true%0#0: uint64 = (getbit p#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%11#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%11#0 ? block@9 : block@10
    block@9: // ternary_true_L225
        let ternary_result%0#0: uint64 = (global Round)
        goto block@11
    block@10: // ternary_false_L225
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@11
    block@11: // ternary_merge_L225
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@9, ternary_result%0#1 <- block@10)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%12#0: bytes = (extract3 p#0 29u 8u) // on error: Index access is out of bounds
        let tmp%13#0: uint64 = (btoi tmp%12#0)
        let tmp%14#0: bool = (>= tmp%13#0 epochRef#0)
        goto tmp%14#0 ? block@12 : block@14
    block@12: // and_contd_L228
        let tmp%15#0: bytes = (extract3 p#0 29u 8u) // on error: Index access is out of bounds
        let tmp%16#0: uint64 = (btoi tmp%15#0)
        let tmp%17#0: uint64 = (- epochRef#0 tmp%16#0)
        let tmp%18#0: bytes = (extract3 p#0 18u 8u) // on error: Index access is out of bounds
        let tmp%19#0: uint64 = (btoi tmp%18#0)
        let tmp%20#0: bool = (>= tmp%17#0 tmp%19#0)
        goto tmp%20#0 ? block@13 : block@14
    block@13: // bool_true_L228
        let and_result%0#0: bool = 1u
        goto block@15
    block@14: // bool_false_L228
        let and_result%0#1: bool = 0u
        goto block@15
    block@15: // bool_merge_L228
        let and_result%0#2: bool = φ(and_result%0#0 <- block@13, and_result%0#1 <- block@14)
        let tmp%21#0: bool = (&& and_result%0#2 methodAllowed#4)
        return tmp%21#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> bool:
    block@0: // L234
        let tmp%0#0: bytes[32] = ((gtxns Sender) txn#0)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L236
        let tmp%2#0: bytes[32] = ((gtxns RekeyTo) txn#0)
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (== tmp%2#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // if_body_L236
        return 1u
    block@3: // after_if_else_L236
        let tmp%5#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%6#0: bool = (== tmp%5#0 6u)
        goto tmp%6#0 ? block@4 : block@9
    block@4: // and_contd_L241
        let tmp%7#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%8#0: uint64 = (global CurrentApplicationID)
        let tmp%9#0: bool = (== tmp%7#0 tmp%8#0)
        goto tmp%9#0 ? block@5 : block@9
    block@5: // and_contd_L241
        let tmp%10#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%11#0: bool = (== tmp%10#0 1u)
        goto tmp%11#0 ? block@6 : block@9
    block@6: // and_contd_L241
        let tmp%12#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%13#0: bool = (== tmp%12#0 0u)
        goto tmp%13#0 ? block@7 : block@9
    block@7: // and_contd_L241
        let tmp%14#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%15#0: bool = (== tmp%14#0 method "arc58_verifyAuthAddr()void")
        goto tmp%15#0 ? block@8 : block@9
    block@8: // bool_true_L241
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L241
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L241
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        return and_result%0#2

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.assertRekeysBack() -> void:
    block@0: // L249
        let rekeysBack#0: bool = 0u
        let tmp%0#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%0#0 1u)
        goto block@1
    block@1: // while_top_L251
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@4)
        let tmp%1#0: uint64 = (global GroupSize)
        let tmp%2#0: bool = (< i#1 tmp%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // while_body_L251
        let txn#0: uint64 = i#1
        let tmp%3#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%3#0 ? block@3 : block@4
    block@3: // if_body_L254
        let rekeysBack#1: bool = 1u
        goto block@6
    block@4: // after_if_else_L254
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@5: // after_while_L251
        goto block@6
    block@6: // L251
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@3, rekeysBack#0 <- block@5)
        (assert rekeysBack#2) // missing rekey back
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key: bytes[40]) -> <bool, bool, bool, bool, bool, bool, bytes[40]>:
    block@0: // L263
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        let exists#0: bool = maybe_exists%0#0
        goto exists#0 ? block@2 : block@1
    block@1: // if_body_L266
        return 0u 1u 1u 1u 0u 0u key#0
    block@2: // after_if_else_L266
        let tmp%1#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let copy%0#0: bytes = maybe_value%1#0
        let pluginInfo#0: bytes = copy%0#0
        let is_true%0#0: uint64 = (getbit pluginInfo#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%2#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%2#0 ? block@3 : block@4
    block@3: // ternary_true_L278
        let ternary_result%0#0: uint64 = (global Round)
        goto block@5
    block@4: // ternary_false_L278
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@5
    block@5: // ternary_merge_L278
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@3, ternary_result%0#1 <- block@4)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%3#0: bytes = (extract3 pluginInfo#0 10u 8u) // on error: Index access is out of bounds
        let tmp%4#0: uint64 = (btoi tmp%3#0)
        let expired#0: bool = (> epochRef#0 tmp%4#0)
        let tmp%5#0: bytes = (extract3 pluginInfo#0 18u 8u) // on error: Index access is out of bounds
        let tmp%6#0: uint64 = (btoi tmp%5#0)
        let hasCooldown#0: bool = (> tmp%6#0 0u)
        let tmp%7#0: bytes = (extract3 pluginInfo#0 29u 8u) // on error: Index access is out of bounds
        let tmp%8#0: uint64 = (btoi tmp%7#0)
        let tmp%9#0: uint64 = (- epochRef#0 tmp%8#0)
        let tmp%10#0: bytes = (extract3 pluginInfo#0 18u 8u) // on error: Index access is out of bounds
        let tmp%11#0: uint64 = (btoi tmp%10#0)
        let onCooldown#0: bool = (< tmp%9#0 tmp%11#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 pluginInfo#0 26u)
        let item_end_offset%0#0: uint64 = (len pluginInfo#0)
        let tmp%12#0: bytes = (substring3 pluginInfo#0 item_start_offset%0#0 item_end_offset%0#0)
        let tmp%13#0: uint64 = (extract_uint16 tmp%12#0 0u)
        let hasMethodRestrictions#0: bool = (> tmp%13#0 0u)
        goto exists#0 ? block@6 : block@9
    block@6: // and_contd_L285
        goto expired#0 ? block@9 : block@7
    block@7: // and_contd_L285
        goto onCooldown#0 ? block@9 : block@8
    block@8: // bool_true_L285
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L285
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L285
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        let valid#0: bool = and_result%0#2
        return exists#0 expired#0 hasCooldown#0 onCooldown#0 hasMethodRestrictions#0 valid#0 key#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key: bytes[40], txn: uint64, methodOffsets: bytes, methodIndex: uint64) -> <bool, bool, bool, bool, bool, bool, bool, bool, bool, bytes[40], bytes>:
    block@0: // L297
        let (pluginCheck%0#0: bool, pluginCheck%1#0: bool, pluginCheck%2#0: bool, pluginCheck%3#0: bool, pluginCheck%4#0: bool, pluginCheck%5#0: bool, pluginCheck%6#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key#0)
        let key#1: bytes[40] = pluginCheck%6#0
        goto 1u ? block@1 : block@2
    block@1: // if_body_L1
        goto block@2
    block@2: // after_if_else_L1
        let check.exists#0: bool = pluginCheck%0#0
        let check.expired#0: bool = pluginCheck%1#0
        let check.hasCooldown#0: bool = pluginCheck%2#0
        let check.onCooldown#0: bool = pluginCheck%3#0
        let check.hasMethodRestrictions#0: bool = pluginCheck%4#0
        let check.valid#0: bool = pluginCheck%5#0
        goto check.valid#0 ? block@4 : block@3
    block@3: // if_body_L306
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 0u 1u 1u check.valid#0 key#1 methodOffsets#0
    block@4: // after_if_else_L306
        let tmp%0#0: bool = (! check.hasMethodRestrictions#0)
        let mCheck.methodAllowed#0: bool = tmp%0#0
        let mCheck.methodHasCooldown#0: bool = 0u
        let mCheck.methodOnCooldown#0: bool = 0u
        goto check.hasMethodRestrictions#0 ? block@5 : block@8
    block@5: // if_body_L321
        let tmp%1#0: uint64 = (extract_uint16 methodOffsets#0 0u)
        let tmp%2#0: bool = (< methodIndex#0 tmp%1#0)
        (assert tmp%2#0) // malformed method offsets
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methodOffsets#0)
        let item_offset%0#0: uint64 = (* methodIndex#0 8u)
        let tmp%3#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let tmp%4#0: uint64 = (btoi tmp%3#0)
        let (methodCheck%0#0: bool, methodCheck%1#0: bool, methodCheck%2#0: bool, methodCheck%3#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.methodCheck(key#1, txn#0, tmp%4#0)
        let key#3: bytes[40] = methodCheck%3#0
        goto 1u ? block@6 : block@7
    block@6: // if_body_L1
        goto block@7
    block@7: // after_if_else_L1
        let mCheck.methodAllowed#1: bool = methodCheck%0#0
        let mCheck.methodHasCooldown#1: bool = methodCheck%1#0
        let mCheck.methodOnCooldown#1: bool = methodCheck%2#0
        goto block@8
    block@8: // after_if_else_L321
        let mCheck.methodAllowed#2: bool = φ(mCheck.methodAllowed#0 <- block@4, mCheck.methodAllowed#1 <- block@7)
        let mCheck.methodHasCooldown#2: bool = φ(mCheck.methodHasCooldown#0 <- block@4, mCheck.methodHasCooldown#1 <- block@7)
        let mCheck.methodOnCooldown#2: bool = φ(mCheck.methodOnCooldown#0 <- block@4, mCheck.methodOnCooldown#1 <- block@7)
        let key#5: bytes[40] = φ(key#1 <- block@4, key#3 <- block@7)
        goto check.valid#0 ? block@9 : block@11
    block@9: // and_contd_L329
        goto mCheck.methodAllowed#2 ? block@10 : block@11
    block@10: // bool_true_L329
        let and_result%0#0: bool = 1u
        goto block@12
    block@11: // bool_false_L329
        let and_result%0#1: bool = 0u
        goto block@12
    block@12: // bool_merge_L329
        let and_result%0#2: bool = φ(and_result%0#0 <- block@10, and_result%0#1 <- block@11)
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 mCheck.methodAllowed#2 mCheck.methodHasCooldown#2 mCheck.methodOnCooldown#2 and_result%0#2 key#5 methodOffsets#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.assertValidGroup(key: bytes[40], methodOffsets: bytes) -> <bytes[40], bytes>:
    block@0: // L339
        let key%out#0: bytes[40] = key#0
        let methodOffsets%out#0: bytes = methodOffsets#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%1#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%1#0 ? block@1 : block@2
    block@1: // ternary_true_L341
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L341
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L341
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let (pluginCheck%0#0: bool, pluginCheck%1#0: bool, pluginCheck%2#0: bool, pluginCheck%3#0: bool, pluginCheck%4#0: bool, pluginCheck%5#0: bool, pluginCheck%6#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key#0)
        let key#2: bytes[40] = pluginCheck%6#0
        goto 1u ? block@4 : block@5
    block@4: // if_body_L1
        let key%out#1: bytes[40] = key#2
        goto block@5
    block@5: // after_if_else_L1
        let key%out#5: bytes[40] = φ(key%out#0 <- block@3, key%out#1 <- block@4)
        let initialCheck.exists#0: bool = pluginCheck%0#0
        let initialCheck.expired#0: bool = pluginCheck%1#0
        let initialCheck.hasCooldown#0: bool = pluginCheck%2#0
        let initialCheck.onCooldown#0: bool = pluginCheck%3#0
        (assert initialCheck.exists#0) // plugin does not exist
        let tmp%2#0: bool = (! initialCheck.expired#0)
        (assert tmp%2#0) // plugin expired
        let tmp%3#0: bool = (! initialCheck.onCooldown#0)
        (assert tmp%3#0) // plugin on cooldown
        let rekeysBack#0: bool = 0u
        let methodIndex#0: uint64 = 0u
        let tmp%4#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%4#0 1u)
        goto block@6
    block@6: // while_top_L354
        let i#1: uint64 = φ(i#0 <- block@5, i#3 <- block@18)
        let key#3: bytes[40] = φ(key#2 <- block@5, key#7 <- block@18)
        let methodOffsets#1: bytes = φ(methodOffsets#0 <- block@5, methodOffsets#5 <- block@18)
        let methodIndex#1: uint64 = φ(methodIndex#0 <- block@5, methodIndex#6 <- block@18)
        let key%out#4: bytes[40] = φ(key%out#5 <- block@5, key%out#7 <- block@18)
        let methodOffsets%out#3: bytes = φ(methodOffsets%out#0 <- block@5, methodOffsets%out#6 <- block@18)
        let tmp%5#0: uint64 = (global GroupSize)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@7 : block@19
    block@7: // while_body_L354
        let txn#0: uint64 = i#1
        let tmp%7#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%7#0 ? block@8 : block@9
    block@8: // if_body_L357
        let rekeysBack#1: bool = 1u
        goto block@20
    block@9: // after_if_else_L357
        let tmp%8#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%9#0: bool = (!= tmp%8#0 6u)
        goto tmp%9#0 ? block@10 : block@11
    block@10: // if_body_L362
        goto block@18
    block@11: // after_if_else_L362
        let tmp%10#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%11#0: bytes = (extract3 key#3 0u 8u) // on error: Index access is out of bounds
        let tmp%12#0: uint64 = (btoi tmp%11#0)
        let tmp%13#0: bool = (== tmp%10#0 tmp%12#0)
        (assert tmp%13#0) // cannot call other apps during rekey
        let tmp%14#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%15#0: bool = (== tmp%14#0 0u)
        (assert tmp%15#0) // invalid oncomplete must be no op
        let tmp%16#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%17#0: bool = (> tmp%16#0 1u)
        (assert tmp%17#0) // invalid sender must be this app id
        let tmp%18#0: bytes = ((gtxnsas ApplicationArgs) txn#0 1u)
        let tmp%19#0: uint64 = (btoi tmp%18#0)
        let tmp%20#0: uint64 = (global CurrentApplicationID)
        let tmp%21#0: bool = (== tmp%19#0 tmp%20#0)
        (assert tmp%21#0) // invalid sender app id
        let (fullPluginCheck%0#0: bool, fullPluginCheck%1#0: bool, fullPluginCheck%2#0: bool, fullPluginCheck%3#0: bool, fullPluginCheck%4#0: bool, fullPluginCheck%5#0: bool, fullPluginCheck%6#0: bool, fullPluginCheck%7#0: bool, fullPluginCheck%8#0: bool, fullPluginCheck%9#0: bytes[40], fullPluginCheck%10#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key#3, txn#0, methodOffsets#1, methodIndex#1)
        let methodOffsets#2: bytes = fullPluginCheck%10#0
        goto 1u ? block@12 : block@13
    block@12: // if_body_L1
        let methodOffsets%out#1: bytes = methodOffsets#2
        goto block@13
    block@13: // after_if_else_L1
        let methodOffsets%out#9: bytes = φ(methodOffsets%out#3 <- block@11, methodOffsets%out#1 <- block@12)
        let key#4: bytes[40] = fullPluginCheck%9#0
        goto 1u ? block@14 : block@15
    block@14: // if_body_L1
        let key%out#2: bytes[40] = key#4
        goto block@15
    block@15: // after_if_else_L1
        let key%out#9: bytes[40] = φ(key%out#4 <- block@13, key%out#2 <- block@14)
        let check.methodOnCooldown#0: bool = fullPluginCheck%7#0
        let check.valid#0: bool = fullPluginCheck%8#0
        let tmp%22#0: bool = (! check.methodOnCooldown#0)
        (assert tmp%22#0) // method on cooldown
        (assert check.valid#0) // invalid plugin call
        goto initialCheck.hasCooldown#0 ? block@16 : block@17
    block@16: // if_body_L378
        let val_as_bytes%0#0: bytes[8] = (itob epochRef#0)
        let tmp%23#0: bytes = (concat "p" key#4)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%23#0)
        (assert maybe_exists%1#0) // Box must have value
        let assigned_value%0#0: bytes[8] = val_as_bytes%0#0
        let updated_data%0#0: bytes = (replace3 maybe_value%1#0 29u assigned_value%0#0)
        (box_del tmp%23#0)
        (box_put tmp%23#0 updated_data%0#0)
        goto block@17
    block@17: // after_if_else_L378
        let methodIndex#5: uint64 = (+ methodIndex#1 1u)
        goto block@18
    block@18: // L354
        let key#7: bytes[40] = φ(key#3 <- block@10, key#4 <- block@17)
        let methodOffsets#5: bytes = φ(methodOffsets#1 <- block@10, methodOffsets#2 <- block@17)
        let methodIndex#6: uint64 = φ(methodIndex#1 <- block@10, methodIndex#5 <- block@17)
        let key%out#7: bytes[40] = φ(key%out#4 <- block@10, key%out#9 <- block@17)
        let methodOffsets%out#6: bytes = φ(methodOffsets%out#3 <- block@10, methodOffsets%out#9 <- block@17)
        let i#3: uint64 = (+ i#1 1u)
        goto block@6
    block@19: // after_while_L354
        goto block@20
    block@20: // L354
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@8, rekeysBack#0 <- block@19)
        (assert rekeysBack#2) // missing rekey back
        return key%out#4 methodOffsets%out#3

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.methodCheck(key: bytes[40], txn: uint64, offset: uint64) -> <bool, bool, bool, bytes[40]>:
    block@0: // L396
        let tmp%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%1#0: uint64 = (len tmp%0#0)
        let tmp%2#0: bool = (== tmp%1#0 4u)
        (assert tmp%2#0) // invalid method signature length
        let to_encode%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let length%0#0: uint64 = (len to_encode%0#0)
        let lengths_equal%0#0: bool = (== length%0#0 4u)
        (assert lengths_equal%0#0) // invalid size
        let selectorArg#0: bytes[4] = to_encode%0#0
        let tmp%3#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%3#0)
        (assert maybe_exists%0#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let tmp%4#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%4#0
        let methods#0: bytes = copy%0#0
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* offset#0 20u)
        let tmp%5#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let copy%1#0: bytes = tmp%5#0
        let allowedMethod#0: bytes[20] = copy%1#0
        let tmp%6#0: bytes = (extract3 allowedMethod#0 4u 8u) // on error: Index access is out of bounds
        let tmp%7#0: uint64 = (btoi tmp%6#0)
        let hasCooldown#0: bool = (> tmp%7#0 0u)
        let tmp%8#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%8#0)
        (assert maybe_exists%1#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let useRounds#0: bool = (getbit encoded_bool%0#0 0u)
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L408
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L408
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L408
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%9#0: bytes = (extract3 allowedMethod#0 12u 8u) // on error: Index access is out of bounds
        let tmp%10#0: uint64 = (btoi tmp%9#0)
        let tmp%11#0: uint64 = (- epochRef#0 tmp%10#0)
        let tmp%12#0: bytes = (extract3 allowedMethod#0 4u 8u) // on error: Index access is out of bounds
        let tmp%13#0: uint64 = (btoi tmp%12#0)
        let onCooldown#0: bool = (< tmp%11#0 tmp%13#0)
        let tmp%14#0: bytes = (extract3 allowedMethod#0 0u 4u) // on error: Index access is out of bounds
        let tmp%15#0: bool = (== tmp%14#0 selectorArg#0)
        goto tmp%15#0 ? block@4 : block@12
    block@4: // and_contd_L411
        goto hasCooldown#0 ? block@5 : block@6
    block@5: // or_contd_L411
        goto onCooldown#0 ? block@12 : block@6
    block@6: // if_body_L411
        goto hasCooldown#0 ? block@7 : block@11
    block@7: // if_body_L413
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L414
        let to_encode%1#0: uint64 = (global Round)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%1#0)
        let ternary_result%1#0: bytes[8] = val_as_bytes%0#0
        goto block@10
    block@9: // ternary_false_L414
        let to_encode%2#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%2#0)
        let ternary_result%1#1: bytes[8] = val_as_bytes%1#0
        goto block@10
    block@10: // ternary_merge_L414
        let ternary_result%1#2: bytes[8] = φ(ternary_result%1#0 <- block@8, ternary_result%1#1 <- block@9)
        let lastCalled#0: bytes[8] = ternary_result%1#2
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* offset#0 20u)
        let tmp%16#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 20u) // on error: Index access is out of bounds
        let assigned_value%0#0: bytes[8] = lastCalled#0
        let updated_data%0#0: bytes = (replace3 tmp%16#0 12u assigned_value%0#0)
        let assigned_value%1#0: bytes = updated_data%0#0
        let array_length%0#0: uint64 = (extract_uint16 methods#0 0u)
        let index_is_in_bounds%0#0: bool = (< offset#0 array_length%0#0)
        (assert index_is_in_bounds%0#0) // Index access is out of bounds
        let write_offset%0#0: uint64 = (* offset#0 20u)
        let write_offset%0#1: uint64 = (+ write_offset%0#0 2u)
        let updated_target%0#0: bytes = (replace3 methods#0 write_offset%0#1 assigned_value%1#0)
        let methods#4: bytes = updated_target%0#0
        let copy%2#0: bytes = methods#4
        let tmp%17#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%17#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%1#0: uint64 = (getbit maybe_value%2#0 0u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let tmp%18#0: bytes = (concat "p" key#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get tmp%18#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%19#0: bytes = (extract3 maybe_value%3#0 1u 1u) // on error: Index access is out of bounds
        let tmp%20#0: bytes = (concat "p" key#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get tmp%20#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%21#0: bytes = (extract3 maybe_value%4#0 2u 8u) // on error: Index access is out of bounds
        let tmp%22#0: bytes = (concat "p" key#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get tmp%22#0)
        (assert maybe_exists%5#0) // Box must have value
        let tmp%23#0: bytes = (extract3 maybe_value%5#0 10u 8u) // on error: Index access is out of bounds
        let tmp%24#0: bytes = (concat "p" key#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get tmp%24#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%25#0: bytes = (extract3 maybe_value%6#0 18u 8u) // on error: Index access is out of bounds
        let tmp%26#0: bytes = (concat "p" key#0)
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (box_get tmp%26#0)
        (assert maybe_exists%7#0) // Box must have value
        let is_true%2#0: uint64 = (getbit maybe_value%7#0 224u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let tmp%27#0: bytes = (concat "p" key#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get tmp%27#0)
        (assert maybe_exists%8#0) // Box must have value
        let is_true%3#0: uint64 = (getbit maybe_value%8#0 225u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let tmp%28#0: bytes = (concat "p" key#0)
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (box_get tmp%28#0)
        (assert maybe_exists%9#0) // Box must have value
        let tmp%29#0: bytes = (extract3 maybe_value%9#0 29u 8u) // on error: Index access is out of bounds
        let tmp%30#0: bytes = (concat "p" key#0)
        let (maybe_value%10#0: bytes, maybe_exists%10#0: bool) = (box_get tmp%30#0)
        (assert maybe_exists%10#0) // Box must have value
        let tmp%31#0: bytes = (extract3 maybe_value%10#0 37u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%1#0: bytes = (concat 0x encoded_bool%1#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%19#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 tmp%21#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 tmp%23#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%25#0)
        let as_bytes%0#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_bool%2#0)
        let is_true%4#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%8#0: bytes = (setbit encoded_tuple_buffer%7#0 225u is_true%4#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 tmp%29#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 tmp%31#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 copy%2#0)
        let tmp%32#0: bytes = (concat "p" key#0)
        (box_del tmp%32#0)
        (box_put tmp%32#0 encoded_tuple_buffer%11#0)
        goto block@11
    block@11: // after_if_else_L413
        return 1u hasCooldown#0 onCooldown#0 key#0
    block@12: // after_if_else_L411
        return 0u 1u 1u key#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.transferFunds(key: bytes[40], fundsRequests: bytes) -> <bytes[40], bytes>:
    block@0: // L439
        let key%out#0: bytes[40] = key#0
        let fundsRequests%out#0: bytes = fundsRequests#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L440
        let i#1: uint64 = φ(i#0 <- block@0, i#3 <- block@7)
        let tmp%0#0: uint64 = (extract_uint16 fundsRequests#0 0u)
        let tmp%1#0: bool = (< i#1 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@8
    block@2: // while_body_L440
        let array_head_and_tail%0#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%0#0: uint64 = (* i#1 16u)
        let tmp%2#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 16u) // on error: Index access is out of bounds
        let copy%0#0: bytes = tmp%2#0
        let request#0: bytes[16] = copy%0#0
        let tmp%3#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%3#0)
        (assert maybe_exists%0#0) // Box must have value
        let copy%1#0: bytes = maybe_value%0#0
        let pluginInfo#0: bytes = copy%1#0
        let tmp%4#0: bytes = (extract3 pluginInfo#0 2u 8u) // on error: Index access is out of bounds
        let tmp%5#0: uint64 = (btoi tmp%4#0)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) tmp%5#0)
        (assert check%0#0) // application exists
        let spendingAddress#0: bytes[32] = value%0#0
        let tmp%6#0: bytes = (extract3 key#0 8u 32u) // on error: Index access is out of bounds
        let tmp%7#0: bytes = (extract3 key#0 0u 8u) // on error: Index access is out of bounds
        let tmp%8#0: bytes = (extract3 request#0 0u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%1#0: bytes = (concat 0x tmp%7#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%6#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 tmp%8#0)
        let allowanceKey#0: bytes[48] = encoded_tuple_buffer%3#0
        let tmp%9#0: bytes = (extract3 pluginInfo#0 37u 8u) // on error: Index access is out of bounds
        let tmp%10#0: uint64 = (btoi tmp%9#0)
        let is_true%0#0: uint64 = (getbit pluginInfo#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%11#0: bool = (getbit encoded_bool%0#0 0u)
        let (verifyAllowance%0#0: bytes[48], verifyAllowance%1#0: bytes[16]) = contracts/abstracted_account.algo.ts::AbstractedAccount.verifyAllowance(tmp%10#0, tmp%11#0, allowanceKey#0, request#0)
        let request#1: bytes[16] = verifyAllowance%1#0
        let tmp%12#0: bytes = (extract3 request#1 0u 8u) // on error: Index access is out of bounds
        let tmp%13#0: uint64 = (btoi tmp%12#0)
        let tmp%14#0: bool = (!= tmp%13#0 0u)
        goto tmp%14#0 ? block@3 : block@5
    block@3: // if_body_L458
        itxn_begin
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%1#0
        let inner_txn_params%0%%param_AssetReceiver_idx_0#0: bytes[32] = spendingAddress#0
        let tmp%15#0: bytes = (extract3 request#1 8u 8u) // on error: Index access is out of bounds
        let inner_txn_params%0%%param_AssetAmount_idx_0#0: uint64 = (btoi tmp%15#0)
        let tmp%16#0: bytes = (extract3 request#1 0u 8u) // on error: Index access is out of bounds
        let inner_txn_params%0%%param_XferAsset_idx_0#0: uint64 = (btoi tmp%16#0)
        ((itxn_field XferAsset) inner_txn_params%0%%param_XferAsset_idx_0#0)
        ((itxn_field AssetAmount) inner_txn_params%0%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) inner_txn_params%0%%param_AssetReceiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        goto block@4
    block@4: // next_txn_L459
        itxn_submit
        goto block@7
    block@5: // else_body_L468
        itxn_begin
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes[32] = maybe_value%2#0
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = spendingAddress#0
        let tmp%17#0: bytes = (extract3 request#1 8u 8u) // on error: Index access is out of bounds
        let inner_txn_params%1%%param_Amount_idx_0#0: uint64 = (btoi tmp%17#0)
        ((itxn_field Amount) inner_txn_params%1%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@6
    block@6: // next_txn_L469
        itxn_submit
        goto block@7
    block@7: // after_if_else_L458
        let i#3: uint64 = (+ i#1 1u)
        goto block@1
    block@8: // after_while_L440
        return key%out#0 fundsRequests%out#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.verifyAllowance(start: uint64, useRounds: bool, key: bytes[48], fundRequest: bytes[16]) -> <bytes[48], bytes[16]>:
    block@0: // L481
        let key%out#0: bytes[48] = key#0
        let fundRequest%out#0: bytes[16] = fundRequest#0
        let tmp%0#0: bytes = (concat "a" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        (assert maybe_exists%0#0) // Allowance does not exist
        let tmp%1#0: bytes = (concat "a" key#0)
        let (maybe_value%1#0: bytes[41], maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let copy%0#0: bytes[41] = maybe_value%1#0
        let allowance#0: bytes[41] = copy%0#0
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L489
        let to_encode%0#0: uint64 = (global Round)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let ternary_result%0#0: bytes[8] = val_as_bytes%0#0
        goto block@3
    block@2: // ternary_false_L489
        let to_encode%1#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%1#0)
        let ternary_result%0#1: bytes[8] = val_as_bytes%1#0
        goto block@3
    block@3: // ternary_merge_L489
        let ternary_result%0#2: bytes[8] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let arc4EpochRef#0: bytes[8] = ternary_result%0#2
        let tmp%2#0: bytes = (extract3 allowance#0 0u 1u) // on error: Index access is out of bounds
        let tmp%3#0: bool = (== tmp%2#0 0x01)
        goto tmp%3#0 ? block@4 : block@5
    block@4: // if_body_L493
        let tmp%4#0: bytes = (extract3 allowance#0 17u 8u) // on error: Index access is out of bounds
        let spent#0: uint64 = (btoi tmp%4#0)
        let tmp%5#0: bytes = (extract3 allowance#0 9u 8u) // on error: Index access is out of bounds
        let tmp%6#0: uint64 = (btoi tmp%5#0)
        let leftover#0: uint64 = (- tmp%6#0 spent#0)
        let tmp%7#0: bytes = (extract3 fundRequest#0 8u 8u) // on error: Index access is out of bounds
        let amount#0: uint64 = (btoi tmp%7#0)
        let tmp%8#0: bool = (>= leftover#0 amount#0)
        (assert tmp%8#0) // Allowance exceeded
        let to_encode%2#0: uint64 = (+ spent#0 amount#0)
        let val_as_bytes%2#0: bytes[8] = (itob to_encode%2#0)
        let tmp%9#0: bytes = (concat "a" key#0)
        let (maybe_value%2#0: bytes[41], maybe_exists%2#0: bool) = (box_get tmp%9#0)
        (assert maybe_exists%2#0) // Box must have value
        let assigned_value%0#0: bytes[8] = val_as_bytes%2#0
        let updated_data%0#0: bytes = (replace3 maybe_value%2#0 17u assigned_value%0#0)
        (box_put tmp%9#0 updated_data%0#0)
        goto block@17
    block@5: // else_body_L501
        let tmp%10#0: bytes = (extract3 allowance#0 0u 1u) // on error: Index access is out of bounds
        let tmp%11#0: bool = (== tmp%10#0 0x02)
        goto tmp%11#0 ? block@6 : block@10
    block@6: // if_body_L501
        let tmp%12#0: bytes = (extract3 allowance#0 25u 8u) // on error: Index access is out of bounds
        let tmp%13#0: uint64 = (btoi tmp%12#0)
        let currentWindowStart#0: uint64 = contracts/abstracted_account.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds#0, start#0, tmp%13#0)
        let tmp%14#0: bytes = (extract3 allowance#0 9u 8u) // on error: Index access is out of bounds
        let allowed#0: uint64 = (btoi tmp%14#0)
        let tmp%15#0: bytes = (extract3 fundRequest#0 8u 8u) // on error: Index access is out of bounds
        let amount₁#0: uint64 = (btoi tmp%15#0)
        let tmp%16#0: bytes = (extract3 allowance#0 17u 8u) // on error: Index access is out of bounds
        let spent₁#0: uint64 = (btoi tmp%16#0)
        let tmp%17#0: bytes = (extract3 allowance#0 33u 8u) // on error: Index access is out of bounds
        let tmp%18#0: uint64 = (btoi tmp%17#0)
        let tmp%19#0: bool = (> currentWindowStart#0 tmp%18#0)
        goto tmp%19#0 ? block@7 : block@8
    block@7: // if_body_L508
        let tmp%20#0: bool = (>= allowed#0 amount₁#0)
        (assert tmp%20#0) // Allowance exceeded
        goto block@9
    block@8: // else_body_L510
        let leftover₁#0: uint64 = (- allowed#0 spent₁#0)
        let tmp%21#0: bool = (>= leftover₁#0 amount₁#0)
        (assert tmp%21#0) // Allowance exceeded
        goto block@9
    block@9: // after_if_else_L508
        let to_encode%3#0: uint64 = (+ spent₁#0 amount₁#0)
        let val_as_bytes%3#0: bytes[8] = (itob to_encode%3#0)
        let newSpent#0: bytes[8] = val_as_bytes%3#0
        let tmp%22#0: bytes = (concat "a" key#0)
        let (maybe_value%3#0: bytes[41], maybe_exists%3#0: bool) = (box_get tmp%22#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%23#0: bytes = (extract3 maybe_value%3#0 0u 1u) // on error: Index access is out of bounds
        let tmp%24#0: bytes = (concat "a" key#0)
        let (maybe_value%4#0: bytes[41], maybe_exists%4#0: bool) = (box_get tmp%24#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%25#0: bytes = (extract3 maybe_value%4#0 1u 8u) // on error: Index access is out of bounds
        let tmp%26#0: bytes = (concat "a" key#0)
        let (maybe_value%5#0: bytes[41], maybe_exists%5#0: bool) = (box_get tmp%26#0)
        (assert maybe_exists%5#0) // Box must have value
        let tmp%27#0: bytes = (extract3 maybe_value%5#0 9u 8u) // on error: Index access is out of bounds
        let tmp%28#0: bytes = (concat "a" key#0)
        let (maybe_value%6#0: bytes[41], maybe_exists%6#0: bool) = (box_get tmp%28#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%29#0: bytes = (extract3 maybe_value%6#0 25u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%1#0: bytes = (concat 0x tmp%23#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%25#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 tmp%27#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 newSpent#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%29#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 arc4EpochRef#0)
        let tmp%30#0: bytes = (concat "a" key#0)
        (box_put tmp%30#0 encoded_tuple_buffer%6#0)
        goto block@16
    block@10: // else_body_L523
        let tmp%31#0: bytes = (extract3 allowance#0 0u 1u) // on error: Index access is out of bounds
        let tmp%32#0: bool = (== tmp%31#0 0x03)
        goto tmp%32#0 ? block@11 : block@15
    block@11: // if_body_L523
        goto useRounds#0 ? block@12 : block@13
    block@12: // ternary_true_L524
        let ternary_result%1#0: uint64 = (global Round)
        goto block@14
    block@13: // ternary_false_L524
        let ternary_result%1#1: uint64 = (global LatestTimestamp)
        goto block@14
    block@14: // ternary_merge_L524
        let ternary_result%1#2: uint64 = φ(ternary_result%1#0 <- block@12, ternary_result%1#1 <- block@13)
        let epochRef#0: uint64 = ternary_result%1#2
        let tmp%33#0: bytes = (extract3 fundRequest#0 8u 8u) // on error: Index access is out of bounds
        let amount₂#0: uint64 = (btoi tmp%33#0)
        let tmp%34#0: bytes = (extract3 allowance#0 1u 8u) // on error: Index access is out of bounds
        let max#0: uint64 = (btoi tmp%34#0)
        let tmp%35#0: bytes = (extract3 allowance#0 25u 8u) // on error: Index access is out of bounds
        let interval#0: uint64 = (btoi tmp%35#0)
        let tmp%36#0: bytes = (extract3 allowance#0 9u 8u) // on error: Index access is out of bounds
        let accrualRate#0: uint64 = (btoi tmp%36#0)
        let tmp%37#0: bytes = (extract3 allowance#0 17u 8u) // on error: Index access is out of bounds
        let lastLeftover#0: uint64 = (btoi tmp%37#0)
        let tmp%38#0: bytes = (extract3 allowance#0 33u 8u) // on error: Index access is out of bounds
        let last#0: uint64 = (btoi tmp%38#0)
        let passed#0: uint64 = (- epochRef#0 last#0)
        let tmp%39#0: uint64 = (/ passed#0 interval#0)
        let tmp%40#0: uint64 = (* tmp%39#0 accrualRate#0)
        let accrued#0: uint64 = (+ lastLeftover#0 tmp%40#0)
        let tmp%41#0: bool = (> accrued#0 max#0)
        let select%0#0: uint64 = (select accrued#0 max#0 tmp%41#0)
        let available#0: uint64 = select%0#0
        let tmp%42#0: bool = (>= available#0 amount₂#0)
        (assert tmp%42#0) // Allowance exceeded
        let to_encode%4#0: uint64 = (- available#0 amount₂#0)
        let val_as_bytes%4#0: bytes[8] = (itob to_encode%4#0)
        let leftover₂#0: bytes[8] = val_as_bytes%4#0
        let tmp%43#0: bytes = (concat "a" key#0)
        let (maybe_value%7#0: bytes[41], maybe_exists%7#0: bool) = (box_get tmp%43#0)
        (assert maybe_exists%7#0) // Box must have value
        let tmp%44#0: bytes = (extract3 maybe_value%7#0 0u 1u) // on error: Index access is out of bounds
        let tmp%45#0: bytes = (concat "a" key#0)
        let (maybe_value%8#0: bytes[41], maybe_exists%8#0: bool) = (box_get tmp%45#0)
        (assert maybe_exists%8#0) // Box must have value
        let tmp%46#0: bytes = (extract3 maybe_value%8#0 1u 8u) // on error: Index access is out of bounds
        let tmp%47#0: bytes = (concat "a" key#0)
        let (maybe_value%9#0: bytes[41], maybe_exists%9#0: bool) = (box_get tmp%47#0)
        (assert maybe_exists%9#0) // Box must have value
        let tmp%48#0: bytes = (extract3 maybe_value%9#0 9u 8u) // on error: Index access is out of bounds
        let tmp%49#0: bytes = (concat "a" key#0)
        let (maybe_value%10#0: bytes[41], maybe_exists%10#0: bool) = (box_get tmp%49#0)
        (assert maybe_exists%10#0) // Box must have value
        let tmp%50#0: bytes = (extract3 maybe_value%10#0 25u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%8#0: bytes = (concat 0x tmp%44#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 tmp%46#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 tmp%48#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 leftover₂#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 tmp%50#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 arc4EpochRef#0)
        let tmp%51#0: bytes = (concat "a" key#0)
        (box_put tmp%51#0 encoded_tuple_buffer%13#0)
        goto block@15
    block@15: // after_if_else_L523
        goto block@16
    block@16: // after_if_else_L501
        goto block@17
    block@17: // after_if_else_L493
        return key%out#0 fundRequest%out#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds: bool, start: uint64, interval: uint64) -> uint64:
    block@0: // L551
        goto useRounds#0 ? block@1 : block@2
    block@1: // if_body_L552
        let tmp%0#0: uint64 = (global Round)
        let tmp%1#0: uint64 = (global Round)
        let tmp%2#0: uint64 = (- tmp%1#0 start#0)
        let tmp%3#0: uint64 = (% tmp%2#0 interval#0)
        let tmp%4#0: uint64 = (- tmp%0#0 tmp%3#0)
        return tmp%4#0
    block@2: // after_if_else_L552
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let tmp%6#0: uint64 = (global LatestTimestamp)
        let tmp%7#0: uint64 = (- tmp%6#0 start#0)
        let tmp%8#0: uint64 = (% tmp%7#0 interval#0)
        let tmp%9#0: uint64 = (- tmp%5#0 tmp%8#0)
        return tmp%9#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.getAuthAddr() -> bytes[32]:
    block@0: // L562
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%1#0: bool = (== maybe_value%0#0 tmp%0#0)
        goto tmp%1#0 ? block@1 : block@2
    block@1: // ternary_true_L563
        let ternary_result%0#0: bytes[32] = (global ZeroAddress)
        goto block@3
    block@2: // ternary_false_L563
        let ternary_result%0#1: bytes[32] = (global CurrentApplicationAddress)
        goto block@3
    block@3: // ternary_merge_L563
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        return ternary_result%0#2

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(controlledAddress: bytes[32], admin: bytes[32]) -> void:
    block@0: // L576
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bool = (== tmp%0#0 controlledAddress#0)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L579
        let tmp%2#0: bytes[32] = (txn Sender)
        let tmp%3#0: bool = (== tmp%2#0 admin#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L579
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L579
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L579
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // sender must be either controlledAddress or admin
        let tmp%4#0: bool = (!= admin#0 controlledAddress#0)
        (assert tmp%4#0)
        (app_global_put "admin" admin#0)
        let tmp%5#0: bytes[32] = (global ZeroAddress)
        let tmp%6#0: bool = (== controlledAddress#0 tmp%5#0)
        goto tmp%6#0 ? block@5 : block@6
    block@5: // ternary_true_L586
        let ternary_result%0#0: bytes[32] = (global CurrentApplicationAddress)
        goto block@7
    block@6: // ternary_false_L586
        let ternary_result%0#1: bytes[32] = controlledAddress#0
        goto block@7
    block@7: // ternary_merge_L586
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@5, ternary_result%0#1 <- block@6)
        (app_global_put "controlled_address" ternary_result%0#2)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes[32]) -> void:
    block@0: // L596
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // only admin can change the admin account
        (app_global_put "admin" newAdmin#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: bytes[8], allowedCaller: bytes[32], newAdmin: bytes[32]) -> void:
    block@0: // L611
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: uint64 = (btoi plugin#0)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) tmp%1#0)
        (assert check%0#0) // application exists
        let tmp%2#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%2#0) // sender must be admin plugin
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%1#0: bytes[32], check%1#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%1#0) // account funded
        let tmp%3#0: uint64 = (btoi plugin#0)
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) tmp%3#0)
        (assert check%2#0) // application exists
        let tmp%4#0: bool = (== value%1#0 value%2#0)
        (assert tmp%4#0) // This plugin is not in control of the account
        let encoded_tuple_buffer%1#0: bytes = (concat 0x plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%5#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%5#0)
        goto maybe_exists%1#0 ? block@1 : block@3
    block@1: // and_contd_L625
        let tmp%6#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%6#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%2#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%7#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%7#0 ? block@2 : block@3
    block@2: // bool_true_L625
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L625
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L625
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // This plugin does not have admin privileges
        (app_global_put "admin" newAdmin#0)
        let tmp%8#0: bytes = (concat "p" key#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get tmp%8#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%9#0: bytes = (extract3 maybe_value%3#0 1u 1u) // on error: Index access is out of bounds
        let tmp%10#0: bool = (== tmp%9#0 0x01)
        goto tmp%10#0 ? block@5 : block@6
    block@5: // if_body_L630
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@6
    block@6: // after_if_else_L630
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes[32]:
    block@0: // L641
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        return maybe_value%0#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
    block@0: // L649
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%0#0) // account funded
        let tmp%0#0: bytes[32] = contracts/abstracted_account.algo.ts::AbstractedAccount.getAuthAddr()
        let tmp%1#0: bool = (== value%0#0 tmp%0#0)
        (assert tmp%1#0)
        let new_state_value%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes[32], flash: bytes[1]) -> void:
    block@0: // L660
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        itxn_begin
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%1#0
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = address#0
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = address#0
        ((itxn_field Note) "rekeying abstracted account")
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@1
    block@1: // next_txn_L663
        itxn_submit
        let tmp%2#0: bool = (getbit flash#0 0u)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // if_body_L673
        contracts/abstracted_account.algo.ts::AbstractedAccount.assertRekeysBack()
        goto block@3
    block@3: // after_if_else_L673
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: bytes[8], global: bool, address: bytes[32], method: bytes[4]) -> bool:
    block@0: // L686
        goto global#0 ? block@1 : block@2
    block@1: // if_body_L693
        let tmp%0#0: bytes[32] = (global ZeroAddress)
        contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, tmp%0#0, method#0)
        goto block@2
    block@2: // after_if_else_L693
        let tmp%1#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, address#0, method#0)
        return tmp%1#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: bytes[8], global: bool, methodOffsets: bytes, fundsRequest: bytes) -> <bytes, bytes>:
    block@0: // L708
        let methodOffsets%out#0: bytes = methodOffsets#0
        let fundsRequest%out#0: bytes = fundsRequest#0
        let pluginApp#0: uint64 = (btoi plugin#0)
        goto global#0 ? block@1 : block@2
    block@1: // ternary_true_L718
        let ternary_result%0#0: bytes[32] = (global ZeroAddress)
        goto block@3
    block@2: // ternary_false_L718
        let ternary_result%0#1: bytes[32] = (txn Sender)
        goto block@3
    block@3: // ternary_merge_L718
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 ternary_result%0#2)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let tmp%1#0: bytes = (extract3 maybe_value%0#0 2u 8u) // on error: Index access is out of bounds
        let tmp%2#0: uint64 = (btoi tmp%1#0)
        let tmp%3#0: bool = (!= tmp%2#0 0u)
        goto tmp%3#0 ? block@4 : block@5
    block@4: // if_body_L723
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%0#0) // application exists
        (app_global_put "spending_address" value%0#0)
        goto block@6
    block@5: // else_body_L725
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        (app_global_put "spending_address" maybe_value%1#0)
        goto block@6
    block@6: // after_if_else_L723
        let (assertValidGroup%0#0: bytes[40], assertValidGroup%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.assertValidGroup(key#0, methodOffsets#0)
        let methodOffsets#3: bytes = assertValidGroup%1#0
        goto 1u ? block@7 : block@8
    block@7: // if_body_L1
        let methodOffsets%out#1: bytes = methodOffsets#3
        goto block@8
    block@8: // after_if_else_L1
        let methodOffsets%out#4: bytes = φ(methodOffsets%out#0 <- block@6, methodOffsets%out#1 <- block@7)
        let key#2: bytes[40] = assertValidGroup%0#0
        let (transferFunds%0#0: bytes[40], transferFunds%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.transferFunds(key#2, fundsRequest#0)
        let fundsRequest#4: bytes = transferFunds%1#0
        goto 1u ? block@9 : block@10
    block@9: // if_body_L1
        let fundsRequest%out#1: bytes = fundsRequest#4
        goto block@10
    block@10: // after_if_else_L1
        let fundsRequest%out#3: bytes = φ(fundsRequest%out#0 <- block@8, fundsRequest%out#1 <- block@9)
        let key#3: bytes[40] = transferFunds%0#0
        itxn_begin
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%2#0
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = maybe_value%3#0
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%1#0) // application exists
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = value%1#0
        ((itxn_field Note) "rekeying to plugin app")
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@11
    block@11: // next_txn_L732
        itxn_submit
        let tmp%4#0: bytes = (concat "p" key#3)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get tmp%4#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%5#0: bytes = (extract3 maybe_value%4#0 1u 1u) // on error: Index access is out of bounds
        let tmp%6#0: bool = (== tmp%5#0 0x01)
        goto tmp%6#0 ? block@12 : block@13
    block@12: // if_body_L742
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@13
    block@13: // after_if_else_L742
        return methodOffsets%out#4 fundsRequest%out#3

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: bool, methodOffsets: bytes, fundsRequest: bytes) -> void:
    block@0: // L757
        let tmp%0#0: bytes = (concat "n" name#0)
        let (maybe_value%0#0: bytes[40], maybe_exists%0#0: bool) = (box_get tmp%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let tmp%1#0: bytes = (extract3 maybe_value%0#0 0u 8u) // on error: Index access is out of bounds
        let (arc58_rekeyToPlugin%0#0: bytes, arc58_rekeyToPlugin%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(tmp%1#0, global#0, methodOffsets#0, fundsRequest#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: bytes[8], allowedCaller: bytes[32], admin: bytes[1], delegationType: bytes[1], lastValid: bytes[8], cooldown: bytes[8], methods: bytes, useAllowance: bytes[1], useRounds: bytes[1]) -> void:
    block@0: // L779
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bool = (== delegationType#0 0x01)
        goto tmp%2#0 ? block@1 : block@3
    block@1: // and_contd_L792
        let tmp%3#0: bytes[32] = (global ZeroAddress)
        let tmp%4#0: bool = (== allowedCaller#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // bool_true_L792
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L792
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L792
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        let badDelegationCombo#0: bool = and_result%0#2
        let tmp%5#0: bool = (! badDelegationCombo#0)
        (assert tmp%5#0) // delegation type must not be self for global plugins
        let encoded_tuple_buffer%1#0: bytes = (concat 0x app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L799
        let i#1: uint64 = φ(i#0 <- block@4, i#2 <- block@6)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@4, methodInfos#2 <- block@6)
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: bool = (< i#1 tmp%6#0)
        goto tmp%7#0 ? block@6 : block@7
    block@6: // while_body_L799
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let tmp%8#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let tmp%9#0: bytes = (extract3 tmp%8#0 0u 4u) // on error: Index access is out of bounds
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let tmp%10#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let tmp%11#0: bytes = (extract3 tmp%10#0 4u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%9#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%11#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let array%encoded%0#1: bytes[20][] = (concat 0x encoded_tuple_buffer%6#0)
        let array%data%0#1: bytes[20][] = (concat 0x array%encoded%0#1)
        let encoded%0#0: bytes[20][] = array%data%0#1
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@5
    block@7: // after_while_L799
        let tmp%12#0: bool = (getbit useRounds#0 0u)
        goto tmp%12#0 ? block@8 : block@9
    block@8: // ternary_true_L807
        let ternary_result%0#0: uint64 = (global Round)
        goto block@10
    block@9: // ternary_false_L807
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@10
    block@10: // ternary_merge_L807
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@8, ternary_result%0#1 <- block@9)
        let epochRef#0: uint64 = ternary_result%0#2
        let spendingApp#0: bytes[8] = 0x0000000000000000
        let tmp%13#0: bool = (getbit useAllowance#0 0u)
        goto tmp%13#0 ? block@11 : block@13
    block@11: // if_body_L814
        itxn_begin
        let to_encode%0#0: uint64 = (btoi app#0)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        ((itxn_field ApplicationArgs) method "createApplication(uint64)void")
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ExtraProgramPages) 0u)
        ((itxn_field LocalNumUint) 0u)
        ((itxn_field LocalNumByteSlice) 0u)
        ((itxn_field GlobalNumByteSlice) 0u)
        ((itxn_field GlobalNumUint) 1u)
        ((itxn_field ClearStateProgramPages) CoEBQw==)
        (itxn_field ClearStateProgramPages)
        ((itxn_field ApprovalProgramPages) CiACAAEmAQlwbHVnaW5faWQxGyITQQCANhoAgASXO2FvgASPFbWCgAQ+oRgygAQkh8MsTwSOBABEADMAFAACIkMxGYEFEkQxGCITRIgArSNC/+0xGSISRDEYIhNEMRYjCUk4ECMSRDYaAReIAEsjQv/OMRkiEkQxGCITRIgAJCNC/70xGSISRDEYIhJENhoBF4gAByNC/6hC/6SKAQAoi/9niTEAMgkSRLEyCbIgIrIII7IQIrIBs4mKAgAxADIJEkAADTEAIihlRHIIRBJBACcjRIv+OAcyChJEi/44CDIQEkSxMgqL/7IRIrISshSBBLIQIrIBs4kiQv/WiQ==)
        (itxn_field ApprovalProgramPages)
        ((itxn_field OnCompletion) 0u)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@12
    block@12: // next_txn_L817
        itxn_submit
        let to_encode%1#0: uint64 = (gitxn 0 CreatedApplicationID)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%1#0)
        let spendingApp#1: bytes[8] = val_as_bytes%1#0
        goto block@13
    block@13: // after_if_else_L814
        let spendingApp#2: bytes[8] = φ(spendingApp#0 <- block@10, spendingApp#1 <- block@12)
        let copy%0#0: bytes = methodInfos#1
        let val_as_bytes%2#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%8#0: bytes = (concat 0x admin#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 spendingApp#2)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 lastValid#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 cooldown#0)
        let as_bytes%1#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 useAllowance#0)
        let is_true%0#0: uint64 = (getbit useRounds#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 copy%0#0)
        let tmp%14#0: bytes = (concat "p" key#0)
        (box_del tmp%14#0)
        (box_put tmp%14#0 encoded_tuple_buffer%18#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: bytes[8], allowedCaller: bytes[32]) -> void:
    block@0: // L850
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let encoded_tuple_buffer%1#0: bytes = (concat 0x app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%2#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%2#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%3#0: bytes = (concat "p" key#0)
        (box_del tmp%3#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: bytes[8], allowedCaller: bytes[32], admin: bytes[1], delegationType: bytes[1], lastValid: bytes[8], cooldown: bytes[8], methods: bytes, useAllowance: bytes[1], useRounds: bytes[1]) -> void:
    block@0: // L875
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bytes = ((extract 2 0) name#0)
        let tmp%3#0: bytes = (concat "n" tmp%2#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%3#0)
        let tmp%4#0: bool = (! maybe_exists%1#0)
        (assert tmp%4#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let copy%0#0: bytes[40] = key#0
        let tmp%5#0: bytes = ((extract 2 0) name#0)
        let tmp%6#0: bytes = (concat "n" tmp%5#0)
        (box_put tmp%6#0 copy%0#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L894
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@2)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@0, methodInfos#2 <- block@2)
        let tmp%7#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%8#0: bool = (< i#1 tmp%7#0)
        goto tmp%8#0 ? block@2 : block@3
    block@2: // while_body_L894
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let tmp%9#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let tmp%10#0: bytes = (extract3 tmp%9#0 0u 4u) // on error: Index access is out of bounds
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let tmp%11#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let tmp%12#0: bytes = (extract3 tmp%11#0 4u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%10#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%12#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let array%encoded%0#1: bytes[20][] = (concat 0x encoded_tuple_buffer%6#0)
        let array%data%0#1: bytes[20][] = (concat 0x array%encoded%0#1)
        let encoded%0#0: bytes[20][] = array%data%0#1
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@3: // after_while_L894
        let spendingApp#0: bytes[8] = 0x0000000000000000
        let tmp%13#0: bool = (getbit useAllowance#0 0u)
        goto tmp%13#0 ? block@4 : block@6
    block@4: // if_body_L903
        itxn_begin
        let to_encode%0#0: uint64 = (btoi app#0)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        ((itxn_field ApplicationArgs) method "createApplication(uint64)void")
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ExtraProgramPages) 0u)
        ((itxn_field LocalNumUint) 0u)
        ((itxn_field LocalNumByteSlice) 0u)
        ((itxn_field GlobalNumByteSlice) 0u)
        ((itxn_field GlobalNumUint) 1u)
        ((itxn_field ClearStateProgramPages) CoEBQw==)
        (itxn_field ClearStateProgramPages)
        ((itxn_field ApprovalProgramPages) CiACAAEmAQlwbHVnaW5faWQxGyITQQCANhoAgASXO2FvgASPFbWCgAQ+oRgygAQkh8MsTwSOBABEADMAFAACIkMxGYEFEkQxGCITRIgArSNC/+0xGSISRDEYIhNEMRYjCUk4ECMSRDYaAReIAEsjQv/OMRkiEkQxGCITRIgAJCNC/70xGSISRDEYIhJENhoBF4gAByNC/6hC/6SKAQAoi/9niTEAMgkSRLEyCbIgIrIII7IQIrIBs4mKAgAxADIJEkAADTEAIihlRHIIRBJBACcjRIv+OAcyChJEi/44CDIQEkSxMgqL/7IRIrISshSBBLIQIrIBs4kiQv/WiQ==)
        (itxn_field ApprovalProgramPages)
        ((itxn_field OnCompletion) 0u)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@5
    block@5: // next_txn_L906
        itxn_submit
        let to_encode%1#0: uint64 = (gitxn 0 CreatedApplicationID)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%1#0)
        let spendingApp#1: bytes[8] = val_as_bytes%1#0
        goto block@6
    block@6: // after_if_else_L903
        let spendingApp#3: bytes[8] = φ(spendingApp#0 <- block@3, spendingApp#1 <- block@5)
        let tmp%14#0: bool = (getbit useRounds#0 0u)
        goto tmp%14#0 ? block@7 : block@8
    block@7: // ternary_true_L914
        let ternary_result%0#0: uint64 = (global Round)
        goto block@9
    block@8: // ternary_false_L914
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@9
    block@9: // ternary_merge_L914
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@7, ternary_result%0#1 <- block@8)
        let epochRef#0: uint64 = ternary_result%0#2
        let copy%1#0: bytes = methodInfos#1
        let val_as_bytes%2#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%8#0: bytes = (concat 0x admin#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 spendingApp#3)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 lastValid#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 cooldown#0)
        let as_bytes%1#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 useAllowance#0)
        let is_true%0#0: uint64 = (getbit useRounds#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 copy%1#0)
        let tmp%15#0: bytes = (concat "p" key#0)
        (box_del tmp%15#0)
        (box_put tmp%15#0 encoded_tuple_buffer%18#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
    block@0: // L939
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bytes = ((extract 2 0) name#0)
        let tmp%3#0: bytes = (concat "n" tmp%2#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%3#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%4#0: bytes = ((extract 2 0) name#0)
        let tmp%5#0: bytes = (concat "n" tmp%4#0)
        let (maybe_value%2#0: bytes[40], maybe_exists%2#0: bool) = (box_get tmp%5#0)
        (assert maybe_exists%2#0) // Box must have value
        let copy%0#0: bytes[40] = maybe_value%2#0
        let app#0: bytes[40] = copy%0#0
        let tmp%6#0: bytes = (concat "p" app#0)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (box_len tmp%6#0)
        (assert maybe_exists%3#0) // plugin does not exist
        let tmp%7#0: bytes = ((extract 2 0) name#0)
        let tmp%8#0: bytes = (concat "n" tmp%7#0)
        (box_del tmp%8#0)
        let tmp%9#0: bytes = (concat "p" app#0)
        (box_del tmp%9#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 