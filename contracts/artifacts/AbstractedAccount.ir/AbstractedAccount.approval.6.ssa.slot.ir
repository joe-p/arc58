main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        goto block@1
    block@1: // L10
        let tmp%0#1: uint64 = (txn NumAppArgs)
        let tmp%1#0: bool = (!= tmp%0#1 0u)
        goto tmp%1#0 ? block@2 : block@20
    block@2: // abi_routing_L10
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "createApplication(address,address,application)void" => block@3, method "arc58_changeAdmin(address)void" => block@4, method "arc58_pluginChangeAdmin(uint64,address,address)void" => block@5, method "arc58_getAdmin()address" => block@6, method "arc58_verifyAuthAddr()void" => block@7, method "arc58_rekeyTo(address,bool)void" => block@8, method "arc58_canCall(uint64,bool,address,byte[4])bool" => block@9, method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void" => block@10, method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void" => block@11, method "arc58_addPlugin(uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@12, method "arc58_removePlugin(uint64,address)void" => block@13, method "arc58_addNamedPlugin(string,uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@14, method "arc58_removeNamedPlugin(string)void" => block@15, method "arc58_addAllowance(uint64,address,uint64,uint8,uint64,uint64,uint64)void" => block@16, method "arc58_removeAllowance(uint64,address,uint64)void" => block@17, * => block@18}
    block@3: // createApplication_route_L421
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (== tmp%3#0 NoOp)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (== tmp%5#0 0u)
        (assert tmp%6#0) // can only call when creating
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 3)
        let tmp%7#0: uint64 = (btoi reinterpret_bytes[1]%0#0)
        let tmp%8#0: uint64 = ((txnas Applications) tmp%7#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0, tmp%8#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0: bool = 1u
        goto block@22
    block@4: // arc58_changeAdmin_route_L443
        let tmp%9#0: uint64 = (txn OnCompletion)
        let tmp%10#0: bool = (== tmp%9#0 NoOp)
        (assert tmp%10#0) // OnCompletion is not NoOp
        let tmp%11#0: uint64 = (txn ApplicationID)
        let tmp%12#0: bool = (!= tmp%11#0 0u)
        (assert tmp%12#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(reinterpret_bytes[32]%2#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1: bool = 1u
        goto block@22
    block@5: // arc58_pluginChangeAdmin_route_L458
        let tmp%13#0: uint64 = (txn OnCompletion)
        let tmp%14#0: bool = (== tmp%13#0 NoOp)
        (assert tmp%14#0) // OnCompletion is not NoOp
        let tmp%15#0: uint64 = (txn ApplicationID)
        let tmp%16#0: bool = (!= tmp%15#0 0u)
        (assert tmp%16#0) // can only call when not creating
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%17#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%4#0: bytes[32] = (txna ApplicationArgs 3)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(tmp%17#0, reinterpret_bytes[32]%3#0, reinterpret_bytes[32]%4#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2: bool = 1u
        goto block@22
    block@6: // arc58_getAdmin_route_L487
        let tmp%18#0: uint64 = (txn OnCompletion)
        let tmp%19#0: bool = (== tmp%18#0 NoOp)
        (assert tmp%19#0) // OnCompletion is not NoOp
        let tmp%20#0: uint64 = (txn ApplicationID)
        let tmp%21#0: bool = (!= tmp%20#0 0u)
        (assert tmp%21#0) // can only call when not creating
        let tmp%22#0: bytes[32] = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin()
        let tmp%23#0: bytes = (concat 0x151f7c75 tmp%22#0)
        (log tmp%23#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3: bool = 1u
        goto block@22
    block@7: // arc58_verifyAuthAddr_route_L495
        let tmp%24#0: uint64 = (txn OnCompletion)
        let tmp%25#0: bool = (== tmp%24#0 NoOp)
        (assert tmp%25#0) // OnCompletion is not NoOp
        let tmp%26#0: uint64 = (txn ApplicationID)
        let tmp%27#0: bool = (!= tmp%26#0 0u)
        (assert tmp%27#0) // can only call when not creating
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr()
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4: bool = 1u
        goto block@22
    block@8: // arc58_rekeyTo_route_L506
        let tmp%28#0: uint64 = (txn OnCompletion)
        let tmp%29#0: bool = (== tmp%28#0 NoOp)
        (assert tmp%29#0) // OnCompletion is not NoOp
        let tmp%30#0: uint64 = (txn ApplicationID)
        let tmp%31#0: bool = (!= tmp%30#0 0u)
        (assert tmp%31#0) // can only call when not creating
        let reinterpret_bytes[32]%5#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%32#0: bool = (getbit reinterpret_bytes[1]%1#0 0u)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(reinterpret_bytes[32]%5#0, tmp%32#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5: bool = 1u
        goto block@22
    block@9: // arc58_canCall_route_L532
        let tmp%33#0: uint64 = (txn OnCompletion)
        let tmp%34#0: bool = (== tmp%33#0 NoOp)
        (assert tmp%34#0) // OnCompletion is not NoOp
        let tmp%35#0: uint64 = (txn ApplicationID)
        let tmp%36#0: bool = (!= tmp%35#0 0u)
        (assert tmp%36#0) // can only call when not creating
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%37#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%38#0: bool = (getbit reinterpret_bytes[1]%2#0 0u)
        let reinterpret_bytes[32]%6#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[4]%0#0: bytes[4] = (txna ApplicationArgs 4)
        let to_encode%0#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(tmp%37#0, tmp%38#0, reinterpret_bytes[32]%6#0, reinterpret_bytes[4]%0#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%39#0: bytes = (concat 0x151f7c75 encoded_bool%0#0)
        (log tmp%39#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6: bool = 1u
        goto block@22
    block@10: // arc58_rekeyToPlugin_route_L554
        let tmp%40#0: uint64 = (txn OnCompletion)
        let tmp%41#0: bool = (== tmp%40#0 NoOp)
        (assert tmp%41#0) // OnCompletion is not NoOp
        let tmp%42#0: uint64 = (txn ApplicationID)
        let tmp%43#0: bool = (!= tmp%42#0 0u)
        (assert tmp%43#0) // can only call when not creating
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%44#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        let reinterpret_bytes[1]%3#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%45#0: bool = (getbit reinterpret_bytes[1]%3#0 0u)
        let tmp%46#0: bytes = (txna ApplicationArgs 3)
        let tmp%47#0: bytes = (txna ApplicationArgs 4)
        let (arc58_rekeyToPlugin%0#0: bytes, arc58_rekeyToPlugin%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(tmp%44#0, tmp%45#0, tmp%46#0, tmp%47#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7: bool = 1u
        goto block@22
    block@11: // arc58_rekeyToNamedPlugin_route_L615
        let tmp%48#0: uint64 = (txn OnCompletion)
        let tmp%49#0: bool = (== tmp%48#0 NoOp)
        (assert tmp%49#0) // OnCompletion is not NoOp
        let tmp%50#0: uint64 = (txn ApplicationID)
        let tmp%51#0: bool = (!= tmp%50#0 0u)
        (assert tmp%51#0) // can only call when not creating
        let tmp%52#0: bytes = (txna ApplicationArgs 1)
        let tmp%53#0: bytes = ((extract 2 0) tmp%52#0)
        let reinterpret_bytes[1]%4#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%54#0: bool = (getbit reinterpret_bytes[1]%4#0 0u)
        let tmp%55#0: bytes = (txna ApplicationArgs 3)
        let tmp%56#0: bytes = (txna ApplicationArgs 4)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(tmp%53#0, tmp%54#0, tmp%55#0, tmp%56#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8: bool = 1u
        goto block@22
    block@12: // arc58_addPlugin_route_L637
        let tmp%57#0: uint64 = (txn OnCompletion)
        let tmp%58#0: bool = (== tmp%57#0 NoOp)
        (assert tmp%58#0) // OnCompletion is not NoOp
        let tmp%59#0: uint64 = (txn ApplicationID)
        let tmp%60#0: bool = (!= tmp%59#0 0u)
        (assert tmp%60#0) // can only call when not creating
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%61#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        let reinterpret_bytes[32]%7#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[1]%5#0: bytes[1] = (txna ApplicationArgs 3)
        let tmp%62#0: bool = (getbit reinterpret_bytes[1]%5#0 0u)
        let reinterpret_bytes[1]%6#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%63#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%64#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let tmp%65#0: bytes = (txna ApplicationArgs 7)
        let reinterpret_bytes[1]%7#0: bytes[1] = (txna ApplicationArgs 8)
        let tmp%66#0: bool = (getbit reinterpret_bytes[1]%7#0 0u)
        let reinterpret_bytes[1]%8#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%67#0: bool = (getbit reinterpret_bytes[1]%8#0 0u)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(tmp%61#0, reinterpret_bytes[32]%7#0, tmp%62#0, reinterpret_bytes[1]%6#0, tmp%63#0, tmp%64#0, tmp%65#0, tmp%66#0, tmp%67#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9: bool = 1u
        goto block@22
    block@13: // arc58_removePlugin_route_L728
        let tmp%68#0: uint64 = (txn OnCompletion)
        let tmp%69#0: bool = (== tmp%68#0 NoOp)
        (assert tmp%69#0) // OnCompletion is not NoOp
        let tmp%70#0: uint64 = (txn ApplicationID)
        let tmp%71#0: bool = (!= tmp%70#0 0u)
        (assert tmp%71#0) // can only call when not creating
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%72#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        let reinterpret_bytes[32]%8#0: bytes[32] = (txna ApplicationArgs 2)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(tmp%72#0, reinterpret_bytes[32]%8#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10: bool = 1u
        goto block@22
    block@14: // arc58_addNamedPlugin_route_L782
        let tmp%73#0: uint64 = (txn OnCompletion)
        let tmp%74#0: bool = (== tmp%73#0 NoOp)
        (assert tmp%74#0) // OnCompletion is not NoOp
        let tmp%75#0: uint64 = (txn ApplicationID)
        let tmp%76#0: bool = (!= tmp%75#0 0u)
        (assert tmp%76#0) // can only call when not creating
        let tmp%77#0: bytes = (txna ApplicationArgs 1)
        let tmp%78#0: bytes = ((extract 2 0) tmp%77#0)
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%79#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        let reinterpret_bytes[32]%9#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%9#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%80#0: bool = (getbit reinterpret_bytes[1]%9#0 0u)
        let reinterpret_bytes[1]%10#0: bytes[1] = (txna ApplicationArgs 5)
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%81#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%82#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        let tmp%83#0: bytes = (txna ApplicationArgs 8)
        let reinterpret_bytes[1]%11#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%84#0: bool = (getbit reinterpret_bytes[1]%11#0 0u)
        let reinterpret_bytes[1]%12#0: bytes[1] = (txna ApplicationArgs 10)
        let tmp%85#0: bool = (getbit reinterpret_bytes[1]%12#0 0u)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(tmp%78#0, tmp%79#0, reinterpret_bytes[32]%9#0, tmp%80#0, reinterpret_bytes[1]%10#0, tmp%81#0, tmp%82#0, tmp%83#0, tmp%84#0, tmp%85#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11: bool = 1u
        goto block@22
    block@15: // arc58_removeNamedPlugin_route_L869
        let tmp%86#0: uint64 = (txn OnCompletion)
        let tmp%87#0: bool = (== tmp%86#0 NoOp)
        (assert tmp%87#0) // OnCompletion is not NoOp
        let tmp%88#0: uint64 = (txn ApplicationID)
        let tmp%89#0: bool = (!= tmp%88#0 0u)
        (assert tmp%89#0) // can only call when not creating
        let tmp%90#0: bytes = (txna ApplicationArgs 1)
        let tmp%91#0: bytes = ((extract 2 0) tmp%90#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(tmp%91#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12: bool = 1u
        goto block@22
    block@16: // arc58_addAllowance_route_L906
        let tmp%92#0: uint64 = (txn OnCompletion)
        let tmp%93#0: bool = (== tmp%92#0 NoOp)
        (assert tmp%93#0) // OnCompletion is not NoOp
        let tmp%94#0: uint64 = (txn ApplicationID)
        let tmp%95#0: bool = (!= tmp%94#0 0u)
        (assert tmp%95#0) // can only call when not creating
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%96#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        let reinterpret_bytes[32]%10#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%11#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%97#0: uint64 = (btoi reinterpret_bytes[8]%11#0)
        let reinterpret_bytes[1]%13#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%12#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%98#0: uint64 = (btoi reinterpret_bytes[8]%12#0)
        let reinterpret_bytes[8]%13#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%99#0: uint64 = (btoi reinterpret_bytes[8]%13#0)
        let reinterpret_bytes[8]%14#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%100#0: uint64 = (btoi reinterpret_bytes[8]%14#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addAllowance(tmp%96#0, reinterpret_bytes[32]%10#0, tmp%97#0, reinterpret_bytes[1]%13#0, tmp%98#0, tmp%99#0, tmp%100#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13: bool = 1u
        goto block@22
    block@17: // arc58_removeAllowance_route_L954
        let tmp%101#0: uint64 = (txn OnCompletion)
        let tmp%102#0: bool = (== tmp%101#0 NoOp)
        (assert tmp%102#0) // OnCompletion is not NoOp
        let tmp%103#0: uint64 = (txn ApplicationID)
        let tmp%104#0: bool = (!= tmp%103#0 0u)
        (assert tmp%104#0) // can only call when not creating
        let reinterpret_bytes[8]%15#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%105#0: uint64 = (btoi reinterpret_bytes[8]%15#0)
        let reinterpret_bytes[32]%11#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%16#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%106#0: uint64 = (btoi reinterpret_bytes[8]%16#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeAllowance(tmp%105#0, reinterpret_bytes[32]%11#0, tmp%106#0)
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#14: bool = 1u
        goto block@22
    block@18: // switch_case_default_L10
        goto block@19
    block@19: // switch_case_next_L10
        goto block@21
    block@20: // bare_routing_L10
        goto block@21
    block@21: // after_if_else_L10
        let contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#15: bool = 0u
        goto block@22
    block@22: // after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router___L1
        let tmp%0#0: bool = φ(contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0 <- block@3, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1 <- block@4, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2 <- block@5, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3 <- block@6, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4 <- block@7, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5 <- block@8, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6 <- block@9, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7 <- block@10, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8 <- block@11, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9 <- block@12, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10 <- block@13, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11 <- block@14, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12 <- block@15, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13 <- block@16, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#14 <- block@17, contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__%0#15 <- block@21)
        return tmp%0#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
    block@0: // L44
        let new_state_value%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_user_interaction" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange() -> void:
    block@0: // L48
        let new_state_value%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_change" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(app: uint64, caller: bytes[32], method: bytes[4]) -> bool:
    block@0: // L52
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 caller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        goto maybe_exists%0#0 ? block@2 : block@1
    block@1: // if_body_L58
        return 0u
    block@2: // after_if_else_L58
        let tmp%1#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%1#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%1#0)
        let tmp%2#0: bytes = (substring3 maybe_value%1#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%2#0
        let methods#0: bytes = copy%0#0
        let tmp%3#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%4#0: bool = (> tmp%3#0 0u)
        let select%0#0: bool = (select 1u 0u tmp%4#0)
        let methodAllowed#0: bool = select%0#0
        let i#0: uint64 = 0u
        goto block@3
    block@3: // while_top_L64
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@6)
        let tmp%5#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@4 : block@7
    block@4: // while_body_L64
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 20u)
        let tmp%7#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let tmp%8#0: bytes = (extract3 tmp%7#0 0u 4u) // on error: Index access is out of bounds
        let tmp%9#0: bool = (== tmp%8#0 method#0)
        goto tmp%9#0 ? block@5 : block@6
    block@5: // if_body_L65
        let methodAllowed#1: bool = 1u
        goto block@8
    block@6: // after_if_else_L65
        let i#2: uint64 = (+ i#1 1u)
        goto block@3
    block@7: // after_while_L64
        goto block@8
    block@8: // L64
        let methodAllowed#4: bool = φ(methodAllowed#1 <- block@5, methodAllowed#0 <- block@7)
        let tmp%10#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%10#0)
        (assert maybe_exists%2#0) // Box must have value
        let copy%1#0: bytes = maybe_value%2#0
        let item4%0#0: bytes = (extract3 copy%1#0 18u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let is_true%2#0: uint64 = (getbit copy%1#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item8%0#0: bytes = (extract3 copy%1#0 29u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let p.cooldown#0: uint64 = item4%1#0
        let p.useRounds#0: bool = item7%0#0
        let p.lastCalled#0: uint64 = item8%1#0
        goto p.useRounds#0 ? block@9 : block@10
    block@9: // ternary_true_L72
        let ternary_result%0#0: uint64 = (global Round)
        goto block@11
    block@10: // ternary_false_L72
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@11
    block@11: // ternary_merge_L72
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@9, ternary_result%0#1 <- block@10)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%11#0: bool = (>= p.lastCalled#0 epochRef#0)
        goto tmp%11#0 ? block@12 : block@14
    block@12: // and_contd_L75
        let tmp%12#0: uint64 = (- epochRef#0 p.lastCalled#0)
        let tmp%13#0: bool = (>= tmp%12#0 p.cooldown#0)
        goto tmp%13#0 ? block@13 : block@14
    block@13: // bool_true_L75
        let and_result%0#0: bool = 1u
        goto block@15
    block@14: // bool_false_L75
        let and_result%0#1: bool = 0u
        goto block@15
    block@15: // bool_merge_L75
        let and_result%0#2: bool = φ(and_result%0#0 <- block@13, and_result%0#1 <- block@14)
        let tmp%14#0: bool = (&& and_result%0#2 methodAllowed#4)
        return tmp%14#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> bool:
    block@0: // L81
        let tmp%0#0: bytes[32] = ((gtxns Sender) txn#0)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L84
        let tmp%2#0: bytes[32] = ((gtxns RekeyTo) txn#0)
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (== tmp%2#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // if_body_L86
        return 1u
    block@3: // after_if_else_L83
        let tmp%5#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%6#0: bool = (== tmp%5#0 6u)
        goto tmp%6#0 ? block@4 : block@9
    block@4: // and_contd_L91
        let tmp%7#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%8#0: uint64 = (global CurrentApplicationID)
        let tmp%9#0: bool = (== tmp%7#0 tmp%8#0)
        goto tmp%9#0 ? block@5 : block@9
    block@5: // and_contd_L91
        let tmp%10#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%11#0: bool = (== tmp%10#0 1u)
        goto tmp%11#0 ? block@6 : block@9
    block@6: // and_contd_L91
        let tmp%12#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%13#0: bool = (== tmp%12#0 0u)
        goto tmp%13#0 ? block@7 : block@9
    block@7: // and_contd_L91
        let tmp%14#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%15#0: bool = (== tmp%14#0 method "arc58_verifyAuthAddr()void")
        goto tmp%15#0 ? block@8 : block@9
    block@8: // bool_true_L91
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L91
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L91
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        return and_result%0#2

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.assertRekeysBack() -> void:
    block@0: // L99
        let rekeysBack#0: bool = 0u
        let tmp%0#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%0#0 1u)
        goto block@1
    block@1: // while_top_L101
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@4)
        let tmp%1#0: uint64 = (global GroupSize)
        let tmp%2#0: bool = (< i#1 tmp%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // while_body_L101
        let txn#0: uint64 = i#1
        let tmp%3#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%3#0 ? block@3 : block@4
    block@3: // if_body_L104
        let rekeysBack#1: bool = 1u
        goto block@6
    block@4: // after_if_else_L104
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@5: // after_while_L101
        goto block@6
    block@6: // L101
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@3, rekeysBack#0 <- block@5)
        (assert rekeysBack#2) // missing rekey back
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key: bytes[40]) -> <bool, bool, bool, bool, bool, bool, bytes[40]>:
    block@0: // L113
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        let exists#0: bool = maybe_exists%0#0
        goto exists#0 ? block@2 : block@1
    block@1: // if_body_L116
        return 0u 1u 1u 1u 0u 0u key#0
    block@2: // after_if_else_L116
        let tmp%1#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let copy%0#0: bytes = maybe_value%1#0
        let item3%0#0: bytes = (extract3 copy%0#0 10u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 copy%0#0 18u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 copy%0#0 26u)
        let item_end_offset%0#0: uint64 = (len copy%0#0)
        let item5%0#0: bytes = (substring3 copy%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%2#0: uint64 = (getbit copy%0#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item8%0#0: bytes = (extract3 copy%0#0 29u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let pluginInfo.lastValid#0: uint64 = item3%1#0
        let pluginInfo.cooldown#0: uint64 = item4%1#0
        let pluginInfo.methods#0: bytes = item5%0#0
        let pluginInfo.useRounds#0: bool = item7%0#0
        let pluginInfo.lastCalled#0: uint64 = item8%1#0
        goto pluginInfo.useRounds#0 ? block@3 : block@4
    block@3: // ternary_true_L128
        let ternary_result%0#0: uint64 = (global Round)
        goto block@5
    block@4: // ternary_false_L128
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@5
    block@5: // ternary_merge_L128
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@3, ternary_result%0#1 <- block@4)
        let epochRef#0: uint64 = ternary_result%0#2
        let expired#0: bool = (> epochRef#0 pluginInfo.lastValid#0)
        let hasCooldown#0: bool = (> pluginInfo.cooldown#0 0u)
        let tmp%2#0: uint64 = (- epochRef#0 pluginInfo.lastCalled#0)
        let onCooldown#0: bool = (< tmp%2#0 pluginInfo.cooldown#0)
        let tmp%3#0: uint64 = (extract_uint16 pluginInfo.methods#0 0u)
        let hasMethodRestrictions#0: bool = (> tmp%3#0 0u)
        goto exists#0 ? block@6 : block@9
    block@6: // and_contd_L135
        goto expired#0 ? block@9 : block@7
    block@7: // and_contd_L135
        goto onCooldown#0 ? block@9 : block@8
    block@8: // bool_true_L135
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L135
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L135
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        let valid#0: bool = and_result%0#2
        return exists#0 expired#0 hasCooldown#0 onCooldown#0 hasMethodRestrictions#0 valid#0 key#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key: bytes[40], txn: uint64, methodOffsets: bytes, methodIndex: uint64) -> <bool, bool, bool, bool, bool, bool, bool, bool, bool, bytes[40], bytes>:
    block@0: // L147
        let (pluginCheck%0#0: bool, pluginCheck%1#0: bool, pluginCheck%2#0: bool, pluginCheck%3#0: bool, pluginCheck%4#0: bool, pluginCheck%5#0: bool, pluginCheck%6#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key#0)
        let key#1: bytes[40] = pluginCheck%6#0
        goto 1u ? block@1 : block@2
    block@1: // if_body_L1
        goto block@2
    block@2: // after_if_else_L1
        let check.exists#0: bool = pluginCheck%0#0
        let check.expired#0: bool = pluginCheck%1#0
        let check.hasCooldown#0: bool = pluginCheck%2#0
        let check.onCooldown#0: bool = pluginCheck%3#0
        let check.hasMethodRestrictions#0: bool = pluginCheck%4#0
        let check.valid#0: bool = pluginCheck%5#0
        goto check.valid#0 ? block@4 : block@3
    block@3: // if_body_L156
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 0u 1u 1u check.valid#0 key#1 methodOffsets#0
    block@4: // after_if_else_L156
        let tmp%0#0: bool = (! check.hasMethodRestrictions#0)
        let mCheck.methodAllowed#0: bool = tmp%0#0
        let mCheck.methodHasCooldown#0: bool = 0u
        let mCheck.methodOnCooldown#0: bool = 0u
        goto check.hasMethodRestrictions#0 ? block@5 : block@8
    block@5: // if_body_L171
        let tmp%1#0: uint64 = (extract_uint16 methodOffsets#0 0u)
        let tmp%2#0: bool = (< methodIndex#0 tmp%1#0)
        (assert tmp%2#0) // malformed method offsets
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methodOffsets#0)
        let item_offset%0#0: uint64 = (* methodIndex#0 8u)
        let tmp%3#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let tmp%4#0: uint64 = (btoi tmp%3#0)
        let (methodCheck%0#0: bool, methodCheck%1#0: bool, methodCheck%2#0: bool, methodCheck%3#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.methodCheck(key#1, txn#0, tmp%4#0)
        let key#3: bytes[40] = methodCheck%3#0
        goto 1u ? block@6 : block@7
    block@6: // if_body_L1
        goto block@7
    block@7: // after_if_else_L1
        let mCheck.methodAllowed#1: bool = methodCheck%0#0
        let mCheck.methodHasCooldown#1: bool = methodCheck%1#0
        let mCheck.methodOnCooldown#1: bool = methodCheck%2#0
        goto block@8
    block@8: // after_if_else_L171
        let mCheck.methodAllowed#2: bool = φ(mCheck.methodAllowed#0 <- block@4, mCheck.methodAllowed#1 <- block@7)
        let mCheck.methodHasCooldown#2: bool = φ(mCheck.methodHasCooldown#0 <- block@4, mCheck.methodHasCooldown#1 <- block@7)
        let mCheck.methodOnCooldown#2: bool = φ(mCheck.methodOnCooldown#0 <- block@4, mCheck.methodOnCooldown#1 <- block@7)
        let key#5: bytes[40] = φ(key#1 <- block@4, key#3 <- block@7)
        goto check.valid#0 ? block@9 : block@11
    block@9: // and_contd_L179
        goto mCheck.methodAllowed#2 ? block@10 : block@11
    block@10: // bool_true_L179
        let and_result%0#0: bool = 1u
        goto block@12
    block@11: // bool_false_L179
        let and_result%0#1: bool = 0u
        goto block@12
    block@12: // bool_merge_L179
        let and_result%0#2: bool = φ(and_result%0#0 <- block@10, and_result%0#1 <- block@11)
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 mCheck.methodAllowed#2 mCheck.methodHasCooldown#2 mCheck.methodOnCooldown#2 and_result%0#2 key#5 methodOffsets#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.assertValidGroup(key: bytes[40], methodOffsets: bytes) -> <bytes[40], bytes>:
    block@0: // L189
        let key%out#0: bytes[40] = key#0
        let methodOffsets%out#0: bytes = methodOffsets#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%1#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%1#0 ? block@1 : block@2
    block@1: // ternary_true_L191
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L191
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L191
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let (pluginCheck%0#0: bool, pluginCheck%1#0: bool, pluginCheck%2#0: bool, pluginCheck%3#0: bool, pluginCheck%4#0: bool, pluginCheck%5#0: bool, pluginCheck%6#0: bytes[40]) = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key#0)
        let key#2: bytes[40] = pluginCheck%6#0
        goto 1u ? block@4 : block@5
    block@4: // if_body_L1
        let key%out#1: bytes[40] = key#2
        goto block@5
    block@5: // after_if_else_L1
        let key%out#5: bytes[40] = φ(key%out#0 <- block@3, key%out#1 <- block@4)
        let initialCheck.exists#0: bool = pluginCheck%0#0
        let initialCheck.expired#0: bool = pluginCheck%1#0
        let initialCheck.hasCooldown#0: bool = pluginCheck%2#0
        let initialCheck.onCooldown#0: bool = pluginCheck%3#0
        (assert initialCheck.exists#0) // plugin does not exist
        let tmp%2#0: bool = (! initialCheck.expired#0)
        (assert tmp%2#0) // plugin expired
        let tmp%3#0: bool = (! initialCheck.onCooldown#0)
        (assert tmp%3#0) // plugin on cooldown
        let rekeysBack#0: bool = 0u
        let methodIndex#0: uint64 = 0u
        let tmp%4#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%4#0 1u)
        goto block@6
    block@6: // while_top_L204
        let i#1: uint64 = φ(i#0 <- block@5, i#3 <- block@18)
        let key#3: bytes[40] = φ(key#2 <- block@5, key#7 <- block@18)
        let methodOffsets#1: bytes = φ(methodOffsets#0 <- block@5, methodOffsets#5 <- block@18)
        let methodIndex#1: uint64 = φ(methodIndex#0 <- block@5, methodIndex#6 <- block@18)
        let key%out#4: bytes[40] = φ(key%out#5 <- block@5, key%out#7 <- block@18)
        let methodOffsets%out#3: bytes = φ(methodOffsets%out#0 <- block@5, methodOffsets%out#6 <- block@18)
        let tmp%5#0: uint64 = (global GroupSize)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@7 : block@19
    block@7: // while_body_L204
        let txn#0: uint64 = i#1
        let tmp%7#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%7#0 ? block@8 : block@9
    block@8: // if_body_L207
        let rekeysBack#1: bool = 1u
        goto block@20
    block@9: // after_if_else_L207
        let tmp%8#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%9#0: bool = (!= tmp%8#0 6u)
        goto tmp%9#0 ? block@10 : block@11
    block@10: // if_body_L212
        goto block@18
    block@11: // after_if_else_L212
        let tmp%10#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%11#0: bytes = (extract3 key#3 0u 8u) // on error: Index access is out of bounds
        let tmp%12#0: uint64 = (btoi tmp%11#0)
        let tmp%13#0: bool = (== tmp%10#0 tmp%12#0)
        (assert tmp%13#0) // cannot call other apps during rekey
        let tmp%14#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%15#0: bool = (== tmp%14#0 0u)
        (assert tmp%15#0) // invalid oncomplete must be no op
        let tmp%16#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%17#0: bool = (> tmp%16#0 1u)
        (assert tmp%17#0) // invalid sender must be this app id
        let tmp%18#0: bytes = ((gtxnsas ApplicationArgs) txn#0 1u)
        let tmp%19#0: uint64 = (btoi tmp%18#0)
        let tmp%20#0: uint64 = (global CurrentApplicationID)
        let tmp%21#0: bool = (== tmp%19#0 tmp%20#0)
        (assert tmp%21#0) // invalid sender app id
        let (fullPluginCheck%0#0: bool, fullPluginCheck%1#0: bool, fullPluginCheck%2#0: bool, fullPluginCheck%3#0: bool, fullPluginCheck%4#0: bool, fullPluginCheck%5#0: bool, fullPluginCheck%6#0: bool, fullPluginCheck%7#0: bool, fullPluginCheck%8#0: bool, fullPluginCheck%9#0: bytes[40], fullPluginCheck%10#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key#3, txn#0, methodOffsets#1, methodIndex#1)
        let methodOffsets#2: bytes = fullPluginCheck%10#0
        goto 1u ? block@12 : block@13
    block@12: // if_body_L1
        let methodOffsets%out#1: bytes = methodOffsets#2
        goto block@13
    block@13: // after_if_else_L1
        let methodOffsets%out#9: bytes = φ(methodOffsets%out#3 <- block@11, methodOffsets%out#1 <- block@12)
        let key#4: bytes[40] = fullPluginCheck%9#0
        goto 1u ? block@14 : block@15
    block@14: // if_body_L1
        let key%out#2: bytes[40] = key#4
        goto block@15
    block@15: // after_if_else_L1
        let key%out#9: bytes[40] = φ(key%out#4 <- block@13, key%out#2 <- block@14)
        let check.methodOnCooldown#0: bool = fullPluginCheck%7#0
        let check.valid#0: bool = fullPluginCheck%8#0
        let tmp%22#0: bool = (! check.methodOnCooldown#0)
        (assert tmp%22#0) // method on cooldown
        (assert check.valid#0) // invalid plugin call
        goto initialCheck.hasCooldown#0 ? block@16 : block@17
    block@16: // if_body_L228
        let val_as_bytes%0#0: bytes[8] = (itob epochRef#0)
        let tmp%23#0: bytes = (concat "p" key#4)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%23#0)
        (assert maybe_exists%1#0) // Box must have value
        let assigned_value%0#0: bytes[8] = val_as_bytes%0#0
        let updated_data%0#0: bytes = (replace3 maybe_value%1#0 29u assigned_value%0#0)
        (box_del tmp%23#0)
        (box_put tmp%23#0 updated_data%0#0)
        goto block@17
    block@17: // after_if_else_L228
        let methodIndex#5: uint64 = (+ methodIndex#1 1u)
        goto block@18
    block@18: // L204
        let key#7: bytes[40] = φ(key#3 <- block@10, key#4 <- block@17)
        let methodOffsets#5: bytes = φ(methodOffsets#1 <- block@10, methodOffsets#2 <- block@17)
        let methodIndex#6: uint64 = φ(methodIndex#1 <- block@10, methodIndex#5 <- block@17)
        let key%out#7: bytes[40] = φ(key%out#4 <- block@10, key%out#9 <- block@17)
        let methodOffsets%out#6: bytes = φ(methodOffsets%out#3 <- block@10, methodOffsets%out#9 <- block@17)
        let i#3: uint64 = (+ i#1 1u)
        goto block@6
    block@19: // after_while_L204
        goto block@20
    block@20: // L204
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@8, rekeysBack#0 <- block@19)
        (assert rekeysBack#2) // missing rekey back
        return key%out#4 methodOffsets%out#3

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.methodCheck(key: bytes[40], txn: uint64, offset: uint64) -> <bool, bool, bool, bytes[40]>:
    block@0: // L246
        let tmp%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%1#0: uint64 = (len tmp%0#0)
        let tmp%2#0: bool = (== tmp%1#0 4u)
        (assert tmp%2#0) // invalid method signature length
        let to_encode%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let length%0#0: uint64 = (len to_encode%0#0)
        let lengths_equal%0#0: bool = (== length%0#0 4u)
        (assert lengths_equal%0#0) // invalid size
        let selectorArg#0: bytes[4] = to_encode%0#0
        let tmp%3#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%3#0)
        (assert maybe_exists%0#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let tmp%4#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%4#0
        let methods#0: bytes = copy%0#0
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* offset#0 20u)
        let tmp%5#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let copy%1#0: bytes = tmp%5#0
        let allowedMethod#0: bytes[20] = copy%1#0
        let tmp%6#0: bytes = (extract3 allowedMethod#0 4u 8u) // on error: Index access is out of bounds
        let tmp%7#0: uint64 = (btoi tmp%6#0)
        let hasCooldown#0: bool = (> tmp%7#0 0u)
        let tmp%8#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%8#0)
        (assert maybe_exists%1#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let useRounds#0: bool = (getbit encoded_bool%0#0 0u)
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L258
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L258
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L258
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%9#0: bytes = (extract3 allowedMethod#0 12u 8u) // on error: Index access is out of bounds
        let tmp%10#0: uint64 = (btoi tmp%9#0)
        let tmp%11#0: uint64 = (- epochRef#0 tmp%10#0)
        let tmp%12#0: bytes = (extract3 allowedMethod#0 4u 8u) // on error: Index access is out of bounds
        let tmp%13#0: uint64 = (btoi tmp%12#0)
        let onCooldown#0: bool = (< tmp%11#0 tmp%13#0)
        let tmp%14#0: bytes = (extract3 allowedMethod#0 0u 4u) // on error: Index access is out of bounds
        let tmp%15#0: bool = (== tmp%14#0 selectorArg#0)
        goto tmp%15#0 ? block@4 : block@12
    block@4: // and_contd_L261
        goto hasCooldown#0 ? block@5 : block@6
    block@5: // or_contd_L261
        goto onCooldown#0 ? block@12 : block@6
    block@6: // if_body_L261
        goto hasCooldown#0 ? block@7 : block@11
    block@7: // if_body_L263
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L264
        let to_encode%1#0: uint64 = (global Round)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%1#0)
        let ternary_result%1#0: bytes[8] = val_as_bytes%0#0
        goto block@10
    block@9: // ternary_false_L264
        let to_encode%2#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%2#0)
        let ternary_result%1#1: bytes[8] = val_as_bytes%1#0
        goto block@10
    block@10: // ternary_merge_L264
        let ternary_result%1#2: bytes[8] = φ(ternary_result%1#0 <- block@8, ternary_result%1#1 <- block@9)
        let lastCalled#0: bytes[8] = ternary_result%1#2
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* offset#0 20u)
        let tmp%16#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 20u) // on error: Index access is out of bounds
        let assigned_value%0#0: bytes[8] = lastCalled#0
        let updated_data%0#0: bytes = (replace3 tmp%16#0 12u assigned_value%0#0)
        let assigned_value%1#0: bytes = updated_data%0#0
        let array_length%0#0: uint64 = (extract_uint16 methods#0 0u)
        let index_is_in_bounds%0#0: bool = (< offset#0 array_length%0#0)
        (assert index_is_in_bounds%0#0) // Index access is out of bounds
        let write_offset%0#0: uint64 = (* offset#0 20u)
        let write_offset%0#1: uint64 = (+ write_offset%0#0 2u)
        let updated_target%0#0: bytes = (replace3 methods#0 write_offset%0#1 assigned_value%1#0)
        let methods#4: bytes = updated_target%0#0
        let copy%2#0: bytes = methods#4
        let tmp%17#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%17#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%1#0: uint64 = (getbit maybe_value%2#0 0u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let tmp%18#0: bytes = (concat "p" key#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get tmp%18#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%19#0: bytes = (extract3 maybe_value%3#0 1u 1u) // on error: Index access is out of bounds
        let tmp%20#0: bytes = (concat "p" key#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get tmp%20#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%21#0: bytes = (extract3 maybe_value%4#0 2u 8u) // on error: Index access is out of bounds
        let tmp%22#0: bytes = (concat "p" key#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get tmp%22#0)
        (assert maybe_exists%5#0) // Box must have value
        let tmp%23#0: bytes = (extract3 maybe_value%5#0 10u 8u) // on error: Index access is out of bounds
        let tmp%24#0: bytes = (concat "p" key#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get tmp%24#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%25#0: bytes = (extract3 maybe_value%6#0 18u 8u) // on error: Index access is out of bounds
        let tmp%26#0: bytes = (concat "p" key#0)
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (box_get tmp%26#0)
        (assert maybe_exists%7#0) // Box must have value
        let is_true%2#0: uint64 = (getbit maybe_value%7#0 224u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let tmp%27#0: bytes = (concat "p" key#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get tmp%27#0)
        (assert maybe_exists%8#0) // Box must have value
        let is_true%3#0: uint64 = (getbit maybe_value%8#0 225u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let tmp%28#0: bytes = (concat "p" key#0)
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (box_get tmp%28#0)
        (assert maybe_exists%9#0) // Box must have value
        let tmp%29#0: bytes = (extract3 maybe_value%9#0 29u 8u) // on error: Index access is out of bounds
        let tmp%30#0: bytes = (concat "p" key#0)
        let (maybe_value%10#0: bytes, maybe_exists%10#0: bool) = (box_get tmp%30#0)
        (assert maybe_exists%10#0) // Box must have value
        let tmp%31#0: bytes = (extract3 maybe_value%10#0 37u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%1#0: bytes = (concat 0x encoded_bool%1#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%19#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 tmp%21#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 tmp%23#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%25#0)
        let as_bytes%0#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_bool%2#0)
        let is_true%4#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%8#0: bytes = (setbit encoded_tuple_buffer%7#0 225u is_true%4#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 tmp%29#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 tmp%31#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 copy%2#0)
        let tmp%32#0: bytes = (concat "p" key#0)
        (box_del tmp%32#0)
        (box_put tmp%32#0 encoded_tuple_buffer%11#0)
        goto block@11
    block@11: // after_if_else_L263
        return 1u hasCooldown#0 onCooldown#0 key#0
    block@12: // after_if_else_L261
        return 0u 1u 1u key#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.transferFunds(key: bytes[40], fundsRequests: bytes) -> <bytes[40], bytes>:
    block@0: // L290
        let key%out#0: bytes[40] = key#0
        let fundsRequests%out#0: bytes = fundsRequests#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L291
        let i#1: uint64 = φ(i#0 <- block@0, i#3 <- block@7)
        let tmp%0#0: uint64 = (extract_uint16 fundsRequests#0 0u)
        let tmp%1#0: bool = (< i#1 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@8
    block@2: // while_body_L291
        let array_head_and_tail%0#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%0#0: uint64 = (* i#1 16u)
        let reinterpret_bytes[16]%0#0: bytes[16] = (extract3 array_head_and_tail%0#0 item_offset%0#0 16u) // on error: Index access is out of bounds
        let item0%0#0: bytes = (extract3 reinterpret_bytes[16]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[16]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let request.asset#0: uint64 = item0%1#0
        let request.amount#0: uint64 = item1%1#0
        let tmp%2#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get tmp%2#0)
        (assert maybe_exists%0#0) // Box must have value
        let copy%0#0: bytes = maybe_value%0#0
        let is_true%2#0: uint64 = (getbit copy%0#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item9%0#0: bytes = (extract3 copy%0#0 37u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let pluginInfo.useRounds#0: bool = item7%0#0
        let pluginInfo.start#0: uint64 = item9%1#0
        let tmp%3#0: bytes = (extract3 key#0 8u 32u) // on error: Index access is out of bounds
        let tmp%4#0: bytes = (extract3 key#0 0u 8u) // on error: Index access is out of bounds
        let val_as_bytes%0#0: bytes[8] = (itob request.asset#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x tmp%4#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%3#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%0#0)
        let allowanceKey#0: bytes[48] = encoded_tuple_buffer%3#0
        let verifyAllowance%0#0: bytes[48] = contracts/abstracted_account.algo.ts::AbstractedAccount.verifyAllowance(pluginInfo.start#0, pluginInfo.useRounds#0, allowanceKey#0, request.asset#0, request.amount#0)
        let tmp%5#0: bool = (!= request.asset#0 0u)
        goto tmp%5#0 ? block@3 : block@5
    block@3: // if_body_L308
        itxn_begin
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%1#0
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let inner_txn_params%0%%param_AssetReceiver_idx_0#0: bytes[32] = maybe_value%2#0
        let inner_txn_params%0%%param_AssetAmount_idx_0#0: uint64 = request.amount#0
        let inner_txn_params%0%%param_XferAsset_idx_0#0: uint64 = request.asset#0
        ((itxn_field XferAsset) inner_txn_params%0%%param_XferAsset_idx_0#0)
        ((itxn_field AssetAmount) inner_txn_params%0%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) inner_txn_params%0%%param_AssetReceiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        goto block@4
    block@4: // next_txn_L309
        itxn_submit
        goto block@7
    block@5: // else_body_L318
        itxn_begin
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes[32] = maybe_value%3#0
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = maybe_value%4#0
        let inner_txn_params%1%%param_Amount_idx_0#0: uint64 = request.amount#0
        ((itxn_field Amount) inner_txn_params%1%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@6
    block@6: // next_txn_L319
        itxn_submit
        goto block@7
    block@7: // after_if_else_L308
        let i#3: uint64 = (+ i#1 1u)
        goto block@1
    block@8: // after_while_L291
        return key%out#0 fundsRequests%out#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.verifyAllowance(start: uint64, useRounds: bool, key: bytes[48], fundRequest.asset: uint64, fundRequest.amount: uint64) -> bytes[48]:
    block@0: // L331
        let key%out#0: bytes[48] = key#0
        let tmp%0#0: bytes = (concat "a" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        (assert maybe_exists%0#0) // Allowance does not exist
        let tmp%1#0: bytes = (concat "a" key#0)
        let (maybe_value%1#0: bytes[41], maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let copy%0#0: bytes[41] = maybe_value%1#0
        let item0%0#0: bytes = (extract3 copy%0#0 0u 1u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 copy%0#0 1u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 copy%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 copy%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 copy%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item5%0#0: bytes = (extract3 copy%0#0 33u 8u) // on error: Index access is out of bounds
        let item5%1#0: uint64 = (btoi item5%0#0)
        let type#0: bytes[1] = item0%0#0
        let spent#0: uint64 = item3%1#0
        let allowed#0: uint64 = item2%1#0
        let last#0: uint64 = item5%1#0
        let max#0: uint64 = item1%1#0
        let interval#0: uint64 = item4%1#0
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L339
        let to_encode%0#0: uint64 = (global Round)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let ternary_result%0#0: bytes[8] = val_as_bytes%0#0
        goto block@3
    block@2: // ternary_false_L339
        let to_encode%1#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%1#0)
        let ternary_result%0#1: bytes[8] = val_as_bytes%1#0
        goto block@3
    block@3: // ternary_merge_L339
        let ternary_result%0#2: bytes[8] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let arc4EpochRef#0: bytes[8] = ternary_result%0#2
        let tmp%2#0: bool = (== type#0 0x01)
        goto tmp%2#0 ? block@4 : block@5
    block@4: // if_body_L343
        let leftover#0: uint64 = (- allowed#0 spent#0)
        let amount#0: uint64 = fundRequest.amount#0
        let tmp%3#0: bool = (>= leftover#0 amount#0)
        (assert tmp%3#0) // Allowance exceeded
        let to_encode%2#0: uint64 = (+ spent#0 amount#0)
        let val_as_bytes%2#0: bytes[8] = (itob to_encode%2#0)
        let tmp%4#0: bytes = (concat "a" key#0)
        let (maybe_value%2#0: bytes[41], maybe_exists%2#0: bool) = (box_get tmp%4#0)
        (assert maybe_exists%2#0) // Box must have value
        let assigned_value%0#0: bytes[8] = val_as_bytes%2#0
        let updated_data%0#0: bytes = (replace3 maybe_value%2#0 17u assigned_value%0#0)
        (box_put tmp%4#0 updated_data%0#0)
        goto block@17
    block@5: // else_body_L350
        let tmp%5#0: bool = (== type#0 0x02)
        goto tmp%5#0 ? block@6 : block@10
    block@6: // if_body_L350
        let currentWindowStart#0: uint64 = contracts/abstracted_account.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds#0, start#0, interval#0)
        let amount₁#0: uint64 = fundRequest.amount#0
        let tmp%6#0: bool = (> currentWindowStart#0 last#0)
        goto tmp%6#0 ? block@7 : block@8
    block@7: // if_body_L354
        let tmp%7#0: bool = (>= allowed#0 amount₁#0)
        (assert tmp%7#0) // Allowance exceeded
        goto block@9
    block@8: // else_body_L356
        let leftover₁#0: uint64 = (- allowed#0 spent#0)
        let tmp%8#0: bool = (>= leftover₁#0 amount₁#0)
        (assert tmp%8#0) // Allowance exceeded
        goto block@9
    block@9: // after_if_else_L354
        let to_encode%3#0: uint64 = (+ spent#0 amount₁#0)
        let val_as_bytes%3#0: bytes[8] = (itob to_encode%3#0)
        let newSpent#0: bytes[8] = val_as_bytes%3#0
        let tmp%9#0: bytes = (concat "a" key#0)
        let (maybe_value%3#0: bytes[41], maybe_exists%3#0: bool) = (box_get tmp%9#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%10#0: bytes = (extract3 maybe_value%3#0 0u 1u) // on error: Index access is out of bounds
        let tmp%11#0: bytes = (concat "a" key#0)
        let (maybe_value%4#0: bytes[41], maybe_exists%4#0: bool) = (box_get tmp%11#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%12#0: bytes = (extract3 maybe_value%4#0 1u 8u) // on error: Index access is out of bounds
        let tmp%13#0: bytes = (concat "a" key#0)
        let (maybe_value%5#0: bytes[41], maybe_exists%5#0: bool) = (box_get tmp%13#0)
        (assert maybe_exists%5#0) // Box must have value
        let tmp%14#0: bytes = (extract3 maybe_value%5#0 9u 8u) // on error: Index access is out of bounds
        let tmp%15#0: bytes = (concat "a" key#0)
        let (maybe_value%6#0: bytes[41], maybe_exists%6#0: bool) = (box_get tmp%15#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%16#0: bytes = (extract3 maybe_value%6#0 25u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%1#0: bytes = (concat 0x tmp%10#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%12#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 tmp%14#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 newSpent#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%16#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 arc4EpochRef#0)
        let tmp%17#0: bytes = (concat "a" key#0)
        (box_put tmp%17#0 encoded_tuple_buffer%6#0)
        goto block@16
    block@10: // else_body_L370
        let tmp%18#0: bool = (== type#0 0x03)
        goto tmp%18#0 ? block@11 : block@15
    block@11: // if_body_L370
        goto useRounds#0 ? block@12 : block@13
    block@12: // ternary_true_L371
        let ternary_result%1#0: uint64 = (global Round)
        goto block@14
    block@13: // ternary_false_L371
        let ternary_result%1#1: uint64 = (global LatestTimestamp)
        goto block@14
    block@14: // ternary_merge_L371
        let ternary_result%1#2: uint64 = φ(ternary_result%1#0 <- block@12, ternary_result%1#1 <- block@13)
        let epochRef#0: uint64 = ternary_result%1#2
        let amount₂#0: uint64 = fundRequest.amount#0
        let accrualRate#0: uint64 = allowed#0
        let lastLeftover#0: uint64 = spent#0
        let passed#0: uint64 = (- epochRef#0 last#0)
        let tmp%19#0: uint64 = (/ passed#0 interval#0)
        let tmp%20#0: uint64 = (* tmp%19#0 accrualRate#0)
        let accrued#0: uint64 = (+ lastLeftover#0 tmp%20#0)
        let tmp%21#0: bool = (> accrued#0 max#0)
        let select%0#0: uint64 = (select accrued#0 max#0 tmp%21#0)
        let available#0: uint64 = select%0#0
        let tmp%22#0: bool = (>= available#0 amount₂#0)
        (assert tmp%22#0) // Allowance exceeded
        let to_encode%4#0: uint64 = (- available#0 amount₂#0)
        let val_as_bytes%4#0: bytes[8] = (itob to_encode%4#0)
        let leftover₂#0: bytes[8] = val_as_bytes%4#0
        let tmp%23#0: bytes = (concat "a" key#0)
        let (maybe_value%7#0: bytes[41], maybe_exists%7#0: bool) = (box_get tmp%23#0)
        (assert maybe_exists%7#0) // Box must have value
        let tmp%24#0: bytes = (extract3 maybe_value%7#0 0u 1u) // on error: Index access is out of bounds
        let tmp%25#0: bytes = (concat "a" key#0)
        let (maybe_value%8#0: bytes[41], maybe_exists%8#0: bool) = (box_get tmp%25#0)
        (assert maybe_exists%8#0) // Box must have value
        let tmp%26#0: bytes = (extract3 maybe_value%8#0 1u 8u) // on error: Index access is out of bounds
        let tmp%27#0: bytes = (concat "a" key#0)
        let (maybe_value%9#0: bytes[41], maybe_exists%9#0: bool) = (box_get tmp%27#0)
        (assert maybe_exists%9#0) // Box must have value
        let tmp%28#0: bytes = (extract3 maybe_value%9#0 9u 8u) // on error: Index access is out of bounds
        let tmp%29#0: bytes = (concat "a" key#0)
        let (maybe_value%10#0: bytes[41], maybe_exists%10#0: bool) = (box_get tmp%29#0)
        (assert maybe_exists%10#0) // Box must have value
        let tmp%30#0: bytes = (extract3 maybe_value%10#0 25u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%8#0: bytes = (concat 0x tmp%24#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 tmp%26#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 tmp%28#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 leftover₂#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 tmp%30#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 arc4EpochRef#0)
        let tmp%31#0: bytes = (concat "a" key#0)
        (box_put tmp%31#0 encoded_tuple_buffer%13#0)
        goto block@15
    block@15: // after_if_else_L370
        goto block@16
    block@16: // after_if_else_L350
        goto block@17
    block@17: // after_if_else_L343
        return key%out#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds: bool, start: uint64, interval: uint64) -> uint64:
    block@0: // L394
        goto useRounds#0 ? block@1 : block@2
    block@1: // if_body_L395
        let tmp%0#0: uint64 = (global Round)
        let tmp%1#0: uint64 = (global Round)
        let tmp%2#0: uint64 = (- tmp%1#0 start#0)
        let tmp%3#0: uint64 = (% tmp%2#0 interval#0)
        let tmp%4#0: uint64 = (- tmp%0#0 tmp%3#0)
        return tmp%4#0
    block@2: // after_if_else_L395
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let tmp%6#0: uint64 = (global LatestTimestamp)
        let tmp%7#0: uint64 = (- tmp%6#0 start#0)
        let tmp%8#0: uint64 = (% tmp%7#0 interval#0)
        let tmp%9#0: uint64 = (- tmp%5#0 tmp%8#0)
        return tmp%9#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.getAuthAddr() -> bytes[32]:
    block@0: // L405
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 maybe_value%1#0)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // ternary_true_L406
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%1#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%2#0: bool = (== maybe_value%2#0 tmp%1#0)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // ternary_true_L407
        let ternary_result%1#0: bytes[32] = (global ZeroAddress)
        goto block@4
    block@3: // ternary_false_L407
        let ternary_result%1#1: bytes[32] = (global CurrentApplicationAddress)
        goto block@4
    block@4: // ternary_merge_L407
        let ternary_result%1#2: bytes[32] = φ(ternary_result%1#0 <- block@2, ternary_result%1#1 <- block@3)
        let ternary_result%0#0: bytes[32] = ternary_result%1#2
        goto block@6
    block@5: // ternary_false_L406
        let ternary_result%0#1: bytes[32] = (global ZeroAddress)
        goto block@6
    block@6: // ternary_merge_L406
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@4, ternary_result%0#1 <- block@5)
        return ternary_result%0#2

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(controlledAddress: bytes[32], admin: bytes[32], spendingAccountFactoryApp: uint64) -> void:
    block@0: // L421
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bool = (== tmp%0#0 controlledAddress#0)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L424
        let tmp%2#0: bytes[32] = (txn Sender)
        let tmp%3#0: bool = (== tmp%2#0 admin#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L424
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L424
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L424
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // sender must be either controlledAddress or admin
        let tmp%4#0: bool = (!= admin#0 controlledAddress#0)
        (assert tmp%4#0)
        (app_global_put "admin" admin#0)
        let tmp%5#0: bytes[32] = (global ZeroAddress)
        let tmp%6#0: bool = (== controlledAddress#0 tmp%5#0)
        goto tmp%6#0 ? block@5 : block@6
    block@5: // ternary_true_L431
        let ternary_result%0#0: bytes[32] = (global CurrentApplicationAddress)
        goto block@7
    block@6: // ternary_false_L431
        let ternary_result%0#1: bytes[32] = controlledAddress#0
        goto block@7
    block@7: // ternary_merge_L431
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@5, ternary_result%0#1 <- block@6)
        (app_global_put "controlled_address" ternary_result%0#2)
        (app_global_put "spend_factory" spendingAccountFactoryApp#0)
        let new_state_value%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" new_state_value%0#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes[32]) -> void:
    block@0: // L443
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // only admin can change the admin account
        (app_global_put "admin" newAdmin#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: bytes[32], newAdmin: bytes[32]) -> void:
    block@0: // L458
        let tmp%0#0: bytes[32] = (txn Sender)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // sender must be admin plugin
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%1#0: bytes[32], check%1#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%1#0) // account funded
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%2#0) // application exists
        let tmp%2#0: bool = (== value%1#0 value%2#0)
        (assert tmp%2#0) // This plugin is not in control of the account
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%3#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%3#0)
        goto maybe_exists%1#0 ? block@1 : block@3
    block@1: // and_contd_L471
        let tmp%4#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%4#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%2#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%5#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%5#0 ? block@2 : block@3
    block@2: // bool_true_L471
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L471
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L471
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // This plugin does not have admin privileges
        (app_global_put "admin" newAdmin#0)
        let tmp%6#0: bytes = (concat "p" key#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get tmp%6#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%7#0: bytes = (extract3 maybe_value%3#0 1u 1u) // on error: Index access is out of bounds
        let tmp%8#0: bool = (== tmp%7#0 0x01)
        goto tmp%8#0 ? block@5 : block@6
    block@5: // if_body_L476
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@6
    block@6: // after_if_else_L476
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes[32]:
    block@0: // L487
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        return maybe_value%0#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
    block@0: // L495
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%0#0) // account funded
        let tmp%0#0: bytes[32] = contracts/abstracted_account.algo.ts::AbstractedAccount.getAuthAddr()
        let tmp%1#0: bool = (== value%0#0 tmp%0#0)
        (assert tmp%1#0)
        let new_state_value%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" new_state_value%0#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes[32], flash: bool) -> void:
    block@0: // L506
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        itxn_begin
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%1#0
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = address#0
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = address#0
        ((itxn_field Note) "rekeying abstracted account")
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@1
    block@1: // next_txn_L509
        itxn_submit
        goto flash#0 ? block@2 : block@3
    block@2: // if_body_L519
        contracts/abstracted_account.algo.ts::AbstractedAccount.assertRekeysBack()
        goto block@3
    block@3: // after_if_else_L519
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: bool, address: bytes[32], method: bytes[4]) -> bool:
    block@0: // L532
        goto global#0 ? block@1 : block@2
    block@1: // if_body_L539
        let tmp%0#0: bytes[32] = (global ZeroAddress)
        contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, tmp%0#0, method#0)
        goto block@2
    block@2: // after_if_else_L539
        let tmp%1#0: bool = contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, address#0, method#0)
        return tmp%1#0

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: bool, methodOffsets: bytes, fundsRequest: bytes) -> <bytes, bytes>:
    block@0: // L554
        let methodOffsets%out#0: bytes = methodOffsets#0
        let fundsRequest%out#0: bytes = fundsRequest#0
        let pluginApp#0: uint64 = plugin#0
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        goto global#0 ? block@1 : block@2
    block@1: // ternary_true_L564
        let ternary_result%0#0: bytes[32] = (global ZeroAddress)
        goto block@3
    block@2: // ternary_false_L564
        let ternary_result%0#1: bytes[32] = (txn Sender)
        goto block@3
    block@3: // ternary_merge_L564
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 ternary_result%0#2)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%0#0: bytes = (concat "p" key#0)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (box_len tmp%0#0)
        (assert maybe_exists%0#0) // plugin does not exist
        let (assertValidGroup%0#0: bytes[40], assertValidGroup%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.assertValidGroup(key#0, methodOffsets#0)
        let methodOffsets#2: bytes = assertValidGroup%1#0
        goto 1u ? block@4 : block@5
    block@4: // if_body_L1
        let methodOffsets%out#1: bytes = methodOffsets#2
        goto block@5
    block@5: // after_if_else_L1
        let methodOffsets%out#5: bytes = φ(methodOffsets%out#0 <- block@3, methodOffsets%out#1 <- block@4)
        let key#1: bytes[40] = assertValidGroup%0#0
        let tmp%1#0: bytes = (concat "p" key#1)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get tmp%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let tmp%2#0: bytes = (extract3 maybe_value%1#0 2u 8u) // on error: Index access is out of bounds
        let tmp%3#0: uint64 = (btoi tmp%2#0)
        let tmp%4#0: bool = (!= tmp%3#0 0u)
        goto tmp%4#0 ? block@6 : block@10
    block@6: // if_body_L573
        let tmp%5#0: bytes = (concat "p" key#1)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%5#0)
        (assert maybe_exists%2#0) // Box must have value
        let tmp%6#0: bytes = (extract3 maybe_value%2#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%6#0)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) spendingApp#0)
        (assert check%0#0) // application exists
        (app_global_put "spending_address" value%0#0)
        let (transferFunds%0#0: bytes[40], transferFunds%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.transferFunds(key#1, fundsRequest#0)
        let fundsRequest#3: bytes = transferFunds%1#0
        goto 1u ? block@7 : block@8
    block@7: // if_body_L1
        let fundsRequest%out#1: bytes = fundsRequest#3
        goto block@8
    block@8: // after_if_else_L1
        let fundsRequest%out#4: bytes = φ(fundsRequest%out#0 <- block@6, fundsRequest%out#1 <- block@7)
        let key#2: bytes[40] = transferFunds%0#0
        itxn_begin
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = spendingApp#0
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%1#0) // application exists
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = value%1#0
        ((itxn_field ApplicationArgs) method "rekey(address)void")
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@9
    block@9: // next_txn_L578
        itxn_submit
        goto block@12
    block@10: // else_body_L586
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        (app_global_put "spending_address" maybe_value%3#0)
        itxn_begin
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes[32] = maybe_value%4#0
        let (maybe_value%5#0: bytes[32], maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%5#0) // check GlobalState exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = maybe_value%5#0
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%2#0) // application exists
        let inner_txn_params%1%%param_RekeyTo_idx_0#0: bytes[32] = value%2#0
        ((itxn_field Note) "rekeying to plugin app")
        ((itxn_field RekeyTo) inner_txn_params%1%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@11
    block@11: // next_txn_L589
        itxn_submit
        goto block@12
    block@12: // after_if_else_L573
        let key#3: bytes[40] = φ(key#2 <- block@9, key#1 <- block@11)
        let fundsRequest%out#3: bytes = φ(fundsRequest%out#4 <- block@9, fundsRequest%out#0 <- block@11)
        let tmp%7#0: bytes = (concat "p" key#3)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get tmp%7#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%8#0: bytes = (extract3 maybe_value%6#0 1u 1u) // on error: Index access is out of bounds
        let tmp%9#0: bool = (== tmp%8#0 0x01)
        goto tmp%9#0 ? block@13 : block@14
    block@13: // if_body_L600
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@14
    block@14: // after_if_else_L600
        return methodOffsets%out#5 fundsRequest%out#3

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: bool, methodOffsets: bytes, fundsRequest: bytes) -> void:
    block@0: // L615
        let tmp%0#0: bytes = (concat "n" name#0)
        let (maybe_value%0#0: bytes[40], maybe_exists%0#0: bool) = (box_get tmp%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let tmp%1#0: bytes = (extract3 maybe_value%0#0 0u 8u) // on error: Index access is out of bounds
        let tmp%2#0: uint64 = (btoi tmp%1#0)
        let (arc58_rekeyToPlugin%0#0: bytes, arc58_rekeyToPlugin%1#0: bytes) = contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(tmp%2#0, global#0, methodOffsets#0, fundsRequest#0)
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: bytes, useAllowance: bool, useRounds: bool) -> void:
    block@0: // L637
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bool = (== delegationType#0 0x01)
        goto tmp%2#0 ? block@1 : block@3
    block@1: // and_contd_L650
        let tmp%3#0: bytes[32] = (global ZeroAddress)
        let tmp%4#0: bool = (== allowedCaller#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // bool_true_L650
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L650
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L650
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        let badDelegationCombo#0: bool = and_result%0#2
        let tmp%5#0: bool = (! badDelegationCombo#0)
        (assert tmp%5#0) // delegation type must not be self for global plugins
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L660
        let i#1: uint64 = φ(i#0 <- block@4, i#2 <- block@6)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@4, methodInfos#2 <- block@6)
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: bool = (< i#1 tmp%6#0)
        goto tmp%7#0 ? block@6 : block@7
    block@6: // while_body_L660
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let tmp%8#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let tmp%9#0: bytes = (extract3 tmp%8#0 0u 4u) // on error: Index access is out of bounds
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let tmp%10#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let tmp%11#0: bytes = (extract3 tmp%10#0 4u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%9#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%11#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let array%encoded%0#1: bytes[20][] = (concat 0x encoded_tuple_buffer%6#0)
        let array%data%0#1: bytes[20][] = (concat 0x array%encoded%0#1)
        let encoded%0#0: bytes[20][] = array%data%0#1
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@5
    block@7: // after_while_L660
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L668
        let ternary_result%0#0: uint64 = (global Round)
        goto block@10
    block@9: // ternary_false_L668
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@10
    block@10: // ternary_merge_L668
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@8, ternary_result%0#1 <- block@9)
        let epochRef#0: uint64 = ternary_result%0#2
        let (maybe_value%1#0: bytes[32], maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%12#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%13#0: bool = (!= maybe_value%1#0 tmp%12#0)
        goto tmp%13#0 ? block@11 : block@13
    block@11: // if_body_L670
        itxn_begin
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%2#0
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%14#0: uint64 = (len methods#0)
        let tmp%15#0: uint64 = (* 400u tmp%14#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%15#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@12
    block@12: // next_txn_L671
        itxn_submit
        goto block@13
    block@13: // after_if_else_L670
        let spendingApp#0: bytes[8] = 0x0000000000000000
        goto useAllowance#0 ? block@14 : block@17
    block@14: // if_body_L682
        itxn_begin
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%3#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%3#0)
        (assert check%0#0) // application exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Amount) 269500u)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@15
    block@15: // next_txn_L690
        itxn_next
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%2%%param_Sender_idx_0#0: bytes[32] = maybe_value%4#0
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%5#0) // check GlobalState exists
        let inner_txn_params%2%%param_ApplicationID_idx_0#0: uint64 = maybe_value%5#0
        let val_as_bytes%1#0: bytes[8] = (itob app#0)
        let inner_txn_params%2%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%1#0
        ((itxn_field ApplicationArgs) method "create(pay,uint64)uint64")
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%2%%param_ApplicationID_idx_0#0)
        ((itxn_field Sender) inner_txn_params%2%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@16
    block@16: // next_txn_L684
        itxn_submit
        let awst_tmp%0#0: bytes = (gitxn 1 LastLog)
        let tmp%16#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%17#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%18#0: bool = (== tmp%17#0 0x151f7c75)
        (assert tmp%18#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%16#0
        let tmp%19#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob tmp%19#0)
        let spendingApp#1: bytes[8] = val_as_bytes%2#0
        goto block@17
    block@17: // after_if_else_L682
        let spendingApp#2: bytes[8] = φ(spendingApp#0 <- block@13, spendingApp#1 <- block@16)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%3#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%4#0: bytes[8] = (itob cooldown#0)
        let copy%0#0: bytes = methodInfos#1
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%5#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%8#0: bytes = (concat 0x encoded_bool%0#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 spendingApp#2)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%4#0)
        let as_bytes%1#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 copy%0#0)
        let tmp%20#0: bytes = (concat "p" key#0)
        (box_del tmp%20#0)
        (box_put tmp%20#0 encoded_tuple_buffer%18#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: uint64, allowedCaller: bytes[32]) -> void:
    block@0: // L728
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let tmp%2#0: bytes = (concat "p" key#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%2#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%3#0: bytes = (concat "p" key#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get tmp%3#0)
        (assert maybe_exists%2#0) // Box must have value
        let tmp%4#0: bytes = (extract3 maybe_value%2#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%4#0)
        let tmp%5#0: bytes = (concat "p" key#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get tmp%5#0)
        (assert maybe_exists%3#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%3#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%3#0)
        let tmp%6#0: bytes = (substring3 maybe_value%3#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%6#0
        let methods#0: bytes = copy%0#0
        let tmp%7#0: bytes = (concat "p" key#0)
        (box_del tmp%7#0)
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let tmp%8#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%9#0: bool = (!= maybe_value%4#0 tmp%8#0)
        goto tmp%9#0 ? block@1 : block@3
    block@1: // if_body_L743
        itxn_begin
        let (maybe_value%5#0: bytes[32], maybe_exists%5#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%5#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = maybe_value%5#0
        let tmp%10#0: uint64 = (len methods#0)
        let tmp%11#0: uint64 = (* 400u tmp%10#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%11#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@2
    block@2: // next_txn_L744
        itxn_submit
        goto block@3
    block@3: // after_if_else_L743
        let tmp%12#0: bool = (!= spendingApp#0 0u)
        goto tmp%12#0 ? block@4 : block@6
    block@4: // if_body_L753
        itxn_begin
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%6#0) // check GlobalState exists
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = maybe_value%6#0
        let val_as_bytes%1#0: bytes[8] = (itob spendingApp#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%1#0
        ((itxn_field ApplicationArgs) method "delete(uint64)void")
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@5
    block@5: // next_txn_L754
        itxn_submit
        goto block@6
    block@6: // after_if_else_L753
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: bytes, useAllowance: bool, useRounds: bool) -> void:
    block@0: // L782
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bytes = (concat "n" name#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%2#0)
        let tmp%3#0: bool = (! maybe_exists%1#0)
        (assert tmp%3#0)
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 allowedCaller#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let copy%0#0: bytes[40] = key#0
        let tmp%4#0: bytes = (concat "n" name#0)
        (box_put tmp%4#0 copy%0#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L804
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@2)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@0, methodInfos#2 <- block@2)
        let tmp%5#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@2 : block@3
    block@2: // while_body_L804
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let tmp%7#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let tmp%8#0: bytes = (extract3 tmp%7#0 0u 4u) // on error: Index access is out of bounds
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let tmp%9#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let tmp%10#0: bytes = (extract3 tmp%9#0 4u 8u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%8#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%10#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let array%encoded%0#1: bytes[20][] = (concat 0x encoded_tuple_buffer%6#0)
        let array%data%0#1: bytes[20][] = (concat 0x array%encoded%0#1)
        let encoded%0#0: bytes[20][] = array%data%0#1
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@3: // after_while_L804
        let (maybe_value%2#0: bytes[32], maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%11#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%12#0: bool = (!= maybe_value%2#0 tmp%11#0)
        goto tmp%12#0 ? block@4 : block@6
    block@4: // if_body_L812
        itxn_begin
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%3#0
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%13#0: uint64 = (len methods#0)
        let tmp%14#0: uint64 = (len name#0)
        let tmp%15#0: uint64 = (+ tmp%13#0 tmp%14#0)
        let tmp%16#0: uint64 = (* 400u tmp%15#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%16#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@5
    block@5: // next_txn_L813
        itxn_submit
        goto block@6
    block@6: // after_if_else_L812
        let spendingApp#0: bytes[8] = 0x0000000000000000
        goto useAllowance#0 ? block@7 : block@10
    block@7: // if_body_L824
        itxn_begin
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes[32] = maybe_value%4#0
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%5#0)
        (assert check%0#0) // application exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Amount) 12500u)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@8
    block@8: // next_txn_L831
        itxn_next
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%6#0) // check GlobalState exists
        let inner_txn_params%2%%param_ApplicationID_idx_0#0: uint64 = maybe_value%6#0
        let val_as_bytes%1#0: bytes[8] = (itob 0u)
        let inner_txn_params%2%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%1#0
        ((itxn_field ApplicationArgs) method "create(pay,uint64)uint64")
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%2%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@9
    block@9: // next_txn_L826
        itxn_submit
        let awst_tmp%0#0: bytes = (gitxn 1 LastLog)
        let tmp%17#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%18#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%19#0: bool = (== tmp%18#0 0x151f7c75)
        (assert tmp%19#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%17#0
        let tmp%20#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob tmp%20#0)
        let spendingApp#1: bytes[8] = val_as_bytes%2#0
        goto block@10
    block@10: // after_if_else_L824
        let spendingApp#3: bytes[8] = φ(spendingApp#0 <- block@6, spendingApp#1 <- block@9)
        goto useRounds#0 ? block@11 : block@12
    block@11: // ternary_true_L845
        let ternary_result%0#0: uint64 = (global Round)
        goto block@13
    block@12: // ternary_false_L845
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@13
    block@13: // ternary_merge_L845
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@11, ternary_result%0#1 <- block@12)
        let epochRef#0: uint64 = ternary_result%0#2
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%3#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%4#0: bytes[8] = (itob cooldown#0)
        let copy%1#0: bytes = methodInfos#1
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%5#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%8#0: bytes = (concat 0x encoded_bool%0#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 spendingApp#3)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%4#0)
        let as_bytes%1#0: bytes[8] = (itob 45u)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 offset_as_uint16%0#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 copy%1#0)
        let tmp%21#0: bytes = (concat "p" key#0)
        (box_del tmp%21#0)
        (box_put tmp%21#0 encoded_tuple_buffer%18#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
    block@0: // L869
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let tmp%2#0: bytes = (concat "n" name#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%2#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%3#0: bytes = (concat "n" name#0)
        let (maybe_value%2#0: bytes[40], maybe_exists%2#0: bool) = (box_get tmp%3#0)
        (assert maybe_exists%2#0) // Box must have value
        let copy%0#0: bytes[40] = maybe_value%2#0
        let app#0: bytes[40] = copy%0#0
        let tmp%4#0: bytes = (concat "p" app#0)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (box_len tmp%4#0)
        (assert maybe_exists%3#0) // plugin does not exist
        let tmp%5#0: bytes = (concat "p" app#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get tmp%5#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%6#0: bytes = (extract3 maybe_value%4#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%6#0)
        let tmp%7#0: bytes = (concat "p" app#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get tmp%7#0)
        (assert maybe_exists%5#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%5#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%5#0)
        let tmp%8#0: bytes = (substring3 maybe_value%5#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%1#0: bytes = tmp%8#0
        let methods#0: bytes = copy%1#0
        let tmp%9#0: bytes = (concat "n" name#0)
        (box_del tmp%9#0)
        let tmp%10#0: bytes = (concat "p" app#0)
        (box_del tmp%10#0)
        let (maybe_value%6#0: bytes[32], maybe_exists%6#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%6#0) // check GlobalState exists
        let tmp%11#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%12#0: bool = (!= maybe_value%6#0 tmp%11#0)
        goto tmp%12#0 ? block@1 : block@3
    block@1: // if_body_L881
        itxn_begin
        let (maybe_value%7#0: bytes[32], maybe_exists%7#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%7#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = maybe_value%7#0
        let tmp%13#0: uint64 = (len methods#0)
        let tmp%14#0: uint64 = (len name#0)
        let tmp%15#0: uint64 = (+ tmp%13#0 tmp%14#0)
        let tmp%16#0: uint64 = (* 400u tmp%15#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%16#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@2
    block@2: // next_txn_L882
        itxn_submit
        goto block@3
    block@3: // after_if_else_L881
        let tmp%17#0: bool = (!= spendingApp#0 0u)
        goto tmp%17#0 ? block@4 : block@6
    block@4: // if_body_L891
        itxn_begin
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "spend_factory")
        (assert maybe_exists%8#0) // check GlobalState exists
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = maybe_value%8#0
        let val_as_bytes%0#0: bytes[8] = (itob spendingApp#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        ((itxn_field ApplicationArgs) method "delete(uint64)void")
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        goto block@5
    block@5: // next_txn_L892
        itxn_submit
        goto block@6
    block@6: // after_if_else_L891
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addAllowance(plugin: uint64, caller: bytes[32], asset: uint64, type: bytes[1], allowed: uint64, max: uint64, interval: uint64) -> void:
    block@0: // L906
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 caller#0)
        let pkey#0: bytes[40] = encoded_tuple_buffer%2#0
        let val_as_bytes%1#0: bytes[8] = (itob asset#0)
        let tmp%2#0: bytes = (extract3 pkey#0 0u 8u) // on error: Index access is out of bounds
        let tmp%3#0: bytes = (extract3 pkey#0 8u 32u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%2#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%3#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%1#0)
        let key#0: bytes[48] = encoded_tuple_buffer%6#0
        let tmp%4#0: bytes = (concat "p" pkey#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%4#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%5#0: bytes = (concat "a" key#0)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (box_len tmp%5#0)
        let tmp%6#0: bool = (! maybe_exists%2#0)
        (assert tmp%6#0) // allowance already exists
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (!= maybe_value%3#0 tmp%7#0)
        goto tmp%8#0 ? block@1 : block@3
    block@1: // if_body_L930
        itxn_begin
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes[32] = maybe_value%4#0
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Amount) 38500u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@2
    block@2: // next_txn_L931
        itxn_submit
        goto block@3
    block@3: // after_if_else_L930
        let val_as_bytes%2#0: bytes[8] = (itob allowed#0)
        let val_as_bytes%3#0: bytes[8] = (itob max#0)
        let val_as_bytes%4#0: bytes[8] = (itob interval#0)
        let encoded_tuple_buffer%8#0: bytes = (concat 0x type#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 0x0000000000000000)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 0x0000000000000000)
        let tmp%9#0: bytes = (concat "a" key#0)
        (box_put tmp%9#0 encoded_tuple_buffer%13#0)
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeAllowance(plugin: uint64, caller: bytes[32], asset: uint64) -> void:
    block@0: // L954
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes[32], maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%1#0: bytes = (concat 0x val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 caller#0)
        let pkey#0: bytes[40] = encoded_tuple_buffer%2#0
        let val_as_bytes%1#0: bytes[8] = (itob asset#0)
        let tmp%2#0: bytes = (extract3 pkey#0 0u 8u) // on error: Index access is out of bounds
        let tmp%3#0: bytes = (extract3 pkey#0 8u 32u) // on error: Index access is out of bounds
        let encoded_tuple_buffer%4#0: bytes = (concat 0x tmp%2#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 tmp%3#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%1#0)
        let key#0: bytes[48] = encoded_tuple_buffer%6#0
        let tmp%4#0: bytes = (concat "p" pkey#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (box_len tmp%4#0)
        (assert maybe_exists%1#0) // plugin does not exist
        let tmp%5#0: bytes = (concat "a" key#0)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (box_len tmp%5#0)
        (assert maybe_exists%2#0) // allowance does not exist
        let tmp%6#0: bytes = (concat "a" key#0)
        (box_del tmp%6#0)
        let (maybe_value%3#0: bytes[32], maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (!= maybe_value%3#0 tmp%7#0)
        goto tmp%8#0 ? block@1 : block@3
    block@1: // if_body_L972
        itxn_begin
        let (maybe_value%4#0: bytes[32], maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = maybe_value%4#0
        ((itxn_field Amount) 38500u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        goto block@2
    block@2: // next_txn_L973
        itxn_submit
        goto block@3
    block@3: // after_if_else_L972
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction()
        contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange()
        return 