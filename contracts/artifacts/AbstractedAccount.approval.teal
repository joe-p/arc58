#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 6 192
    bytecblock "a" "c" "p" 0x0f885493 0x00 "n" 0x151f7c75 0x0000000000000000
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0xb4c77d71 0xd24b7556 0x5fa449c6 0x13bc44e4 // method "createApplication(address,address)void", method "arc58_changeAdmin(address)void", method "arc58_pluginChangeAdmin(uint64,address,address)void", method "arc58_getAdmin()address"
    bytec_3 // method "arc58_verifyAuthAddr()void"
    pushbytess 0xc95a5d3d 0xe9026da8 0x7c766ddc 0x56f28b58 0xd12dcb61 0x4d372355 0x8a72a750 0xe350b9d4 // method "arc58_rekeyTo(address,bool)void", method "arc58_canCall(uint64,address)bool", method "arc58_rekeyToPlugin(uint64)void", method "arc58_rekeyToNamedPlugin(string)void", method "arc58_addPlugin(uint64,address,uint64,uint64,bool)void", method "arc58_removePlugin(uint64,address)void", method "arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool)void", method "arc58_removeNamedPlugin(string)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_arc58_changeAdmin_route@4 main_arc58_pluginChangeAdmin_route@5 main_arc58_getAdmin_route@6 main_arc58_verifyAuthAddr_route@7 main_arc58_rekeyTo_route@8 main_arc58_canCall_route@9 main_arc58_rekeyToPlugin_route@10 main_arc58_rekeyToNamedPlugin_route@11 main_arc58_addPlugin_route@12 main_arc58_removePlugin_route@13 main_arc58_addNamedPlugin_route@14 main_arc58_removeNamedPlugin_route@15

main_after_if_else@19:
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    intc_0 // 0
    return

main_arc58_removeNamedPlugin_route@15:
    // contracts/abstracted_account.algo.ts:388
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // contracts/abstracted_account.algo.ts:388
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    return

main_arc58_addNamedPlugin_route@14:
    // contracts/abstracted_account.algo.ts:358-365
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // contracts/abstracted_account.algo.ts:358-365
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    callsub arc58_addNamedPlugin
    intc_1 // 1
    return

main_arc58_removePlugin_route@13:
    // contracts/abstracted_account.algo.ts:338
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/abstracted_account.algo.ts:338
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    callsub arc58_removePlugin
    intc_1 // 1
    return

main_arc58_addPlugin_route@12:
    // contracts/abstracted_account.algo.ts:312-318
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // contracts/abstracted_account.algo.ts:312-318
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    callsub arc58_addPlugin
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@11:
    // contracts/abstracted_account.algo.ts:298
    // arc58_rekeyToNamedPlugin(name: arc4.Str): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // contracts/abstracted_account.algo.ts:298
    // arc58_rekeyToNamedPlugin(name: arc4.Str): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@10:
    // contracts/abstracted_account.algo.ts:261
    // arc58_rekeyToPlugin(plugin: arc4.UintN64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // contracts/abstracted_account.algo.ts:261
    // arc58_rekeyToPlugin(plugin: arc4.UintN64): void {
    callsub arc58_rekeyToPlugin
    intc_1 // 1
    return

main_arc58_canCall_route@9:
    // contracts/abstracted_account.algo.ts:248
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/abstracted_account.algo.ts:248
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_rekeyTo_route@8:
    // contracts/abstracted_account.algo.ts:210
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/abstracted_account.algo.ts:210
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    return

main_arc58_verifyAuthAddr_route@7:
    // contracts/abstracted_account.algo.ts:200
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    return

main_arc58_getAdmin_route@6:
    // contracts/abstracted_account.algo.ts:192
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_pluginChangeAdmin_route@5:
    // contracts/abstracted_account.algo.ts:169
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/abstracted_account.algo.ts:169
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    return

main_arc58_changeAdmin_route@4:
    // contracts/abstracted_account.algo.ts:155
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // contracts/abstracted_account.algo.ts:155
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    return

main_createApplication_route@3:
    // contracts/abstracted_account.algo.ts:134
    // @abimethod({ onCreate: 'require'})
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // contracts/abstracted_account.algo.ts:24
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/abstracted_account.algo.ts:134
    // @abimethod({ onCreate: 'require'})
    callsub createApplication
    intc_1 // 1
    return


// contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(controlledAddress: bytes, admin: bytes) -> void:
createApplication:
    // contracts/abstracted_account.algo.ts:134-135
    // @abimethod({ onCreate: 'require'})
    // createApplication(controlledAddress: arc4.Address, admin: arc4.Address) {
    proto 2 0
    // contracts/abstracted_account.algo.ts:140
    // Txn.sender === controlledAddress.native
    txn Sender
    frame_dig -2
    ==
    // contracts/abstracted_account.algo.ts:140-141
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bnz createApplication_bool_true@2
    // contracts/abstracted_account.algo.ts:141
    // || Txn.sender === admin.native,
    txn Sender
    frame_dig -1
    ==
    // contracts/abstracted_account.algo.ts:140-141
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bz createApplication_bool_false@3

createApplication_bool_true@2:
    intc_1 // 1

createApplication_bool_merge@4:
    // contracts/abstracted_account.algo.ts:139-143
    // assert(
    //   Txn.sender === controlledAddress.native
    //   || Txn.sender === admin.native,
    //   'Sender must be either controlledAddress or admin'
    // );
    assert // Sender must be either controlledAddress or admin
    // contracts/abstracted_account.algo.ts:144
    // assert(admin !== controlledAddress);
    frame_dig -1
    frame_dig -2
    !=
    assert
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    bytec_0 // "a"
    // contracts/abstracted_account.algo.ts:146
    // this.admin.value = admin.native;
    frame_dig -1
    app_global_put
    // contracts/abstracted_account.algo.ts:147
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    frame_dig -2
    global ZeroAddress
    ==
    bz createApplication_ternary_false@6
    global CurrentApplicationAddress

createApplication_ternary_merge@7:
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    bytec_1 // "c"
    // contracts/abstracted_account.algo.ts:147
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    swap
    app_global_put
    retsub

createApplication_ternary_false@6:
    frame_dig -2
    b createApplication_ternary_merge@7

createApplication_bool_false@3:
    intc_0 // 0
    b createApplication_bool_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // contracts/abstracted_account.algo.ts:155
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    proto 1 0
    // contracts/abstracted_account.algo.ts:157
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:157
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    bytec_0 // "a"
    // contracts/abstracted_account.algo.ts:158
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: bytes, allowedCaller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // contracts/abstracted_account.algo.ts:169
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    proto 3 0
    // contracts/abstracted_account.algo.ts:171
    // assert(Txn.sender === Application(plugin.native).address, 'Sender must be the plugin');
    txn Sender
    frame_dig -3
    btoi
    dup
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Sender must be the plugin
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:173
    // this.controlledAddress.value.authAddress === Application(plugin.native).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/abstracted_account.algo.ts:172-175
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin.native).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // contracts/abstracted_account.algo.ts:177
    // const key = new PluginsKey({ application: plugin, allowedCaller: allowedCaller });
    frame_dig -3
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:179
    // const [p, exists] = this.plugins.maybe(key);
    swap
    concat
    box_get
    // contracts/abstracted_account.algo.ts:181
    // exists && p.adminPrivileges.native,
    bz arc58_pluginChangeAdmin_bool_false@3
    frame_dig 0
    intc_3 // 192
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // contracts/abstracted_account.algo.ts:180-183
    // assert(
    //   exists && p.adminPrivileges.native,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    bytec_0 // "a"
    // contracts/abstracted_account.algo.ts:185
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:194
    // return new arc4.Address(this.admin.value);
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:
    // contracts/abstracted_account.algo.ts:200
    // arc58_verifyAuthAddr(): void {
    proto 0 0
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:201
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr());
    acct_params_get AcctAuthAddr
    assert // account funded
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:122
    // return this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // contracts/abstracted_account.algo.ts:122-124
    // return this.controlledAddress.value === Global.currentApplicationAddress
    //   ? Global.zeroAddress // contract controls itself
    //   : Global.currentApplicationAddress; // contract controls a different account
    bz arc58_verifyAuthAddr_ternary_false@3
    // contracts/abstracted_account.algo.ts:123
    // ? Global.zeroAddress // contract controls itself
    global ZeroAddress

arc58_verifyAuthAddr_ternary_merge@4:
    // contracts/abstracted_account.algo.ts:201
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr());
    frame_dig 0
    ==
    assert
    retsub

arc58_verifyAuthAddr_ternary_false@3:
    // contracts/abstracted_account.algo.ts:124
    // : Global.currentApplicationAddress; // contract controls a different account
    global CurrentApplicationAddress
    b arc58_verifyAuthAddr_ternary_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: bytes) -> void:
arc58_rekeyTo:
    // contracts/abstracted_account.algo.ts:210
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    proto 2 0
    pushbytes ""
    dup
    // contracts/abstracted_account.algo.ts:212
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:212
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:214-222
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:219
    // note: 'rekeying abstracted account',
    pushbytes "rekeying abstracted account"
    itxn_field Note
    frame_dig -2
    itxn_field RekeyTo
    frame_dig -2
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:214-221
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:220
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // contracts/abstracted_account.algo.ts:214-222
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // contracts/abstracted_account.algo.ts:224
    // if (flash.native) this.verifyRekeyToAbstractedAccount();
    frame_dig -1
    intc_0 // 0
    getbit
    bz arc58_rekeyTo_after_if_else@3
    // contracts/abstracted_account.algo.ts:46
    // let rekeyedBack = false;
    intc_0 // 0
    frame_bury 1
    // contracts/abstracted_account.algo.ts:48
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 0

arc58_rekeyTo_while_top@5:
    // contracts/abstracted_account.algo.ts:48
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    global GroupSize
    <
    bz arc58_rekeyTo_block@17
    // contracts/abstracted_account.algo.ts:52
    // if (txn.sender === this.controlledAddress.value && txn.rekeyTo === Global.currentApplicationAddress) {
    frame_dig 0
    gtxns Sender
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:52
    // if (txn.sender === this.controlledAddress.value && txn.rekeyTo === Global.currentApplicationAddress) {
    ==
    bz arc58_rekeyTo_after_if_else@9
    frame_dig 0
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    bz arc58_rekeyTo_after_if_else@9
    // contracts/abstracted_account.algo.ts:53
    // rekeyedBack = true;
    intc_1 // 1
    frame_bury 1

arc58_rekeyTo_block@17:
    // contracts/abstracted_account.algo.ts:71
    // assert(rekeyedBack);
    frame_dig 1
    assert

arc58_rekeyTo_after_if_else@3:
    retsub

arc58_rekeyTo_after_if_else@9:
    // contracts/abstracted_account.algo.ts:59
    // txn.type === TransactionType.ApplicationCall
    frame_dig 0
    gtxns TypeEnum
    intc_2 // 6
    ==
    // contracts/abstracted_account.algo.ts:59-60
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyTo_after_if_else@15
    // contracts/abstracted_account.algo.ts:60
    // && txn.appId === Global.currentApplicationId
    frame_dig 0
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // contracts/abstracted_account.algo.ts:59-60
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyTo_after_if_else@15
    // contracts/abstracted_account.algo.ts:62
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    frame_dig 0
    gtxns OnCompletion
    // contracts/abstracted_account.algo.ts:59-62
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    bnz arc58_rekeyTo_after_if_else@15
    // contracts/abstracted_account.algo.ts:63
    // && txn.numAppArgs === 1
    frame_dig 0
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // contracts/abstracted_account.algo.ts:59-63
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    // && txn.numAppArgs === 1
    bz arc58_rekeyTo_after_if_else@15
    // contracts/abstracted_account.algo.ts:64
    // && txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    frame_dig 0
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec_3 // method "arc58_verifyAuthAddr()void"
    ==
    // contracts/abstracted_account.algo.ts:59-64
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    // && txn.numAppArgs === 1
    // && txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    bz arc58_rekeyTo_after_if_else@15
    // contracts/abstracted_account.algo.ts:66
    // rekeyedBack = true;
    intc_1 // 1
    frame_bury 1
    // contracts/abstracted_account.algo.ts:67
    // break;
    b arc58_rekeyTo_block@17

arc58_rekeyTo_after_if_else@15:
    // contracts/abstracted_account.algo.ts:48
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_rekeyTo_while_top@5


// contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(app: uint64, caller: bytes) -> uint64:
pluginCallAllowed:
    // contracts/abstracted_account.algo.ts:227
    // private pluginCallAllowed(app: Application, caller: Account): boolean {
    proto 2 1
    // contracts/abstracted_account.algo.ts:229
    // application: new arc4.UintN64(app.id),
    frame_dig -2
    itob
    // contracts/abstracted_account.algo.ts:228-231
    // const key = new PluginsKey({
    //   application: new arc4.UintN64(app.id),
    //   allowedCaller: new arc4.Address(caller)
    // });
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:233
    // const [plugin, exists] = this.plugins.maybe(key);
    swap
    concat
    box_get
    // contracts/abstracted_account.algo.ts:236-237
    // exists
    // && plugin.lastValidRound.native >= Global.round
    bz pluginCallAllowed_bool_false@4
    // contracts/abstracted_account.algo.ts:237
    // && plugin.lastValidRound.native >= Global.round
    frame_dig 0
    intc_0 // 0
    extract_uint64
    global Round
    >=
    // contracts/abstracted_account.algo.ts:236-237
    // exists
    // && plugin.lastValidRound.native >= Global.round
    bz pluginCallAllowed_bool_false@4
    // contracts/abstracted_account.algo.ts:238
    // && Global.round - plugin.lastCalled.native >= plugin.cooldown.native
    global Round
    frame_dig 0
    dup
    cover 2
    pushint 16 // 16
    extract_uint64
    -
    swap
    pushint 8 // 8
    extract_uint64
    >=
    // contracts/abstracted_account.algo.ts:236-238
    // exists
    // && plugin.lastValidRound.native >= Global.round
    // && Global.round - plugin.lastCalled.native >= plugin.cooldown.native
    bz pluginCallAllowed_bool_false@4
    intc_1 // 1

pluginCallAllowed_bool_merge@5:
    // contracts/abstracted_account.algo.ts:235-239
    // return (
    //   exists
    //   && plugin.lastValidRound.native >= Global.round
    //   && Global.round - plugin.lastCalled.native >= plugin.cooldown.native
    // );
    swap
    retsub

pluginCallAllowed_bool_false@4:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@5


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: bytes, address: bytes) -> uint64:
arc58_canCall:
    // contracts/abstracted_account.algo.ts:248-249
    // @abimethod({ readonly: true })
    // arc58_canCall(plugin: arc4.UintN64, address: arc4.Address): boolean {
    proto 2 1
    // contracts/abstracted_account.algo.ts:250
    // const globalAllowed = this.pluginCallAllowed(Application(plugin.native), Global.zeroAddress);
    frame_dig -2
    btoi
    dup
    global ZeroAddress
    callsub pluginCallAllowed
    // contracts/abstracted_account.algo.ts:251
    // if (globalAllowed) return true;
    bz arc58_canCall_after_if_else@2
    intc_1 // 1
    swap
    retsub

arc58_canCall_after_if_else@2:
    // contracts/abstracted_account.algo.ts:253
    // return this.pluginCallAllowed(Application(plugin.native), address.native);
    frame_dig 0
    frame_dig -1
    callsub pluginCallAllowed
    swap
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: bytes) -> void:
arc58_rekeyToPlugin:
    // contracts/abstracted_account.algo.ts:261
    // arc58_rekeyToPlugin(plugin: arc4.UintN64): void {
    proto 1 0
    pushbytes ""
    dupn 2
    // contracts/abstracted_account.algo.ts:262
    // const globalAllowed = this.pluginCallAllowed(Application(plugin.native), Global.zeroAddress);
    frame_dig -1
    btoi
    dup
    global ZeroAddress
    callsub pluginCallAllowed
    dup
    // contracts/abstracted_account.algo.ts:264
    // if (!globalAllowed) {
    bnz arc58_rekeyToPlugin_after_if_else@2
    // contracts/abstracted_account.algo.ts:265
    // assert(this.pluginCallAllowed(Application(plugin.native), Txn.sender), 'This sender is not allowed to trigger this plugin');
    frame_dig 3
    txn Sender
    callsub pluginCallAllowed
    assert // This sender is not allowed to trigger this plugin

arc58_rekeyToPlugin_after_if_else@2:
    // contracts/abstracted_account.algo.ts:268-276
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:272
    // rekeyTo: Application(plugin.native).address,
    frame_dig 3
    app_params_get AppAddress
    assert // application exists
    // contracts/abstracted_account.algo.ts:273
    // note: 'rekeying to plugin app',
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:268-275
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:274
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // contracts/abstracted_account.algo.ts:268-276
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // contracts/abstracted_account.algo.ts:280
    // allowedCaller: new arc4.Address(globalAllowed ? Global.zeroAddress : Txn.sender)
    frame_dig 4
    bz arc58_rekeyToPlugin_ternary_false@8
    global ZeroAddress

arc58_rekeyToPlugin_ternary_merge@9:
    // contracts/abstracted_account.algo.ts:278-281
    // const key = new PluginsKey({
    //   application: plugin,
    //   allowedCaller: new arc4.Address(globalAllowed ? Global.zeroAddress : Txn.sender)
    // });
    frame_dig -1
    swap
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:283
    // const previousValue = this.plugins.get(key);
    swap
    concat
    dup
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:284-287
    // const newValue = new PluginInfo({
    //   ...previousValue,
    //   lastCalled: new arc4.UintN64(Global.round),
    // });
    dup
    extract 0 8 // on error: Index access is out of bounds
    dig 1
    intc_3 // 192
    getbit
    uncover 2
    extract 8 8 // on error: Index access is out of bounds
    // contracts/abstracted_account.algo.ts:286
    // lastCalled: new arc4.UintN64(Global.round),
    global Round
    itob
    // contracts/abstracted_account.algo.ts:284-287
    // const newValue = new PluginInfo({
    //   ...previousValue,
    //   lastCalled: new arc4.UintN64(Global.round),
    // });
    bytec 4 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:289
    // this.plugins.set(key, newValue);
    box_put
    // contracts/abstracted_account.algo.ts:78
    // let rekeyedBack = false;
    intc_0 // 0
    frame_bury 1
    // contracts/abstracted_account.algo.ts:80
    // for (let i: uint64 = (Txn.groupIndex + 1); i < (Global.groupSize - Txn.groupIndex); i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 0

arc58_rekeyToPlugin_while_top@11:
    // contracts/abstracted_account.algo.ts:80
    // for (let i: uint64 = (Txn.groupIndex + 1); i < (Global.groupSize - Txn.groupIndex); i += 1) {
    global GroupSize
    txn GroupIndex
    -
    frame_dig 0
    >
    bz arc58_rekeyToPlugin_block@25
    // contracts/abstracted_account.algo.ts:84
    // if (txn.sender === this.controlledAddress.value && txn.rekeyTo === Global.currentApplicationAddress) {
    frame_dig 0
    gtxns Sender
    // contracts/abstracted_account.algo.ts:30
    // controlledAddress = GlobalState<Account>({ key: 'c' });
    intc_0 // 0
    bytec_1 // "c"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:84
    // if (txn.sender === this.controlledAddress.value && txn.rekeyTo === Global.currentApplicationAddress) {
    ==
    bz arc58_rekeyToPlugin_after_if_else@15
    frame_dig 0
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    bz arc58_rekeyToPlugin_after_if_else@15
    // contracts/abstracted_account.algo.ts:85
    // rekeyedBack = true;
    intc_1 // 1
    frame_bury 1

arc58_rekeyToPlugin_block@25:
    // contracts/abstracted_account.algo.ts:114
    // assert(rekeyedBack);
    frame_dig 1
    assert
    retsub

arc58_rekeyToPlugin_after_if_else@15:
    // contracts/abstracted_account.algo.ts:91
    // txn.type === TransactionType.ApplicationCall
    frame_dig 0
    gtxns TypeEnum
    dup
    frame_bury 2
    intc_2 // 6
    ==
    // contracts/abstracted_account.algo.ts:91-92
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyToPlugin_after_if_else@21
    // contracts/abstracted_account.algo.ts:92
    // && txn.appId === Global.currentApplicationId
    frame_dig 0
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // contracts/abstracted_account.algo.ts:91-92
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyToPlugin_after_if_else@21
    // contracts/abstracted_account.algo.ts:94
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    frame_dig 0
    gtxns OnCompletion
    // contracts/abstracted_account.algo.ts:91-94
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    bnz arc58_rekeyToPlugin_after_if_else@21
    // contracts/abstracted_account.algo.ts:95
    // && txn.numAppArgs === 1
    frame_dig 0
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // contracts/abstracted_account.algo.ts:91-95
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    // && txn.numAppArgs === 1
    bz arc58_rekeyToPlugin_after_if_else@21
    // contracts/abstracted_account.algo.ts:96
    // && txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    frame_dig 0
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec_3 // method "arc58_verifyAuthAddr()void"
    ==
    // contracts/abstracted_account.algo.ts:91-96
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // // @ts-expect-error
    // && txn.onCompletion === arc4.OnCompleteAction.NoOp
    // && txn.numAppArgs === 1
    // && txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    bz arc58_rekeyToPlugin_after_if_else@21
    // contracts/abstracted_account.algo.ts:98
    // rekeyedBack = true;
    intc_1 // 1
    frame_bury 1
    // contracts/abstracted_account.algo.ts:99
    // break;
    b arc58_rekeyToPlugin_block@25

arc58_rekeyToPlugin_after_if_else@21:
    // contracts/abstracted_account.algo.ts:102
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 2
    intc_2 // 6
    !=
    bnz arc58_rekeyToPlugin_block@23
    // contracts/abstracted_account.algo.ts:106
    // assert(txn.appId === Application(app), 'Invalid app call');
    frame_dig 0
    dup
    gtxns ApplicationID
    frame_dig 3
    ==
    assert // Invalid app call
    // contracts/abstracted_account.algo.ts:108
    // assert(txn.onCompletion === arc4.OnCompleteAction.NoOp, 'Invalid onCompletion');
    dup
    gtxns OnCompletion
    !
    assert // Invalid onCompletion
    // contracts/abstracted_account.algo.ts:109
    // assert(txn.numAppArgs > 1, 'Invalid number of app args');
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // Invalid number of app args
    // contracts/abstracted_account.algo.ts:110
    // assert(len(txn.appArgs(1)) === 8, 'Invalid app arg length');
    intc_1 // 1
    gtxnsas ApplicationArgs
    dup
    len
    pushint 8 // 8
    ==
    assert // Invalid app arg length
    // contracts/abstracted_account.algo.ts:111
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, 'Invalid app arg');
    btoi
    global CurrentApplicationID
    ==
    assert // Invalid app arg

arc58_rekeyToPlugin_block@23:
    // contracts/abstracted_account.algo.ts:80
    // for (let i: uint64 = (Txn.groupIndex + 1); i < (Global.groupSize - Txn.groupIndex); i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_rekeyToPlugin_while_top@11

arc58_rekeyToPlugin_ternary_false@8:
    // contracts/abstracted_account.algo.ts:280
    // allowedCaller: new arc4.Address(globalAllowed ? Global.zeroAddress : Txn.sender)
    txn Sender
    b arc58_rekeyToPlugin_ternary_merge@9


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // contracts/abstracted_account.algo.ts:298
    // arc58_rekeyToNamedPlugin(name: arc4.Str): void {
    proto 1 0
    // contracts/abstracted_account.algo.ts:299
    // this.arc58_rekeyToPlugin(this.namedPlugins.get(name.native).application);
    frame_dig -1
    extract 2 0
    // contracts/abstracted_account.algo.ts:40
    // namedPlugins = BoxMap<string, PluginsKey>({ keyPrefix: 'n' });
    bytec 5 // "n"
    // contracts/abstracted_account.algo.ts:299
    // this.arc58_rekeyToPlugin(this.namedPlugins.get(name.native).application);
    swap
    concat
    box_get
    assert // Box must have value
    extract 0 8 // on error: Index access is out of bounds
    callsub arc58_rekeyToPlugin
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: bytes, allowedCaller: bytes, lastValidRound: bytes, cooldown: bytes, adminPrivileges: bytes) -> void:
arc58_addPlugin:
    // contracts/abstracted_account.algo.ts:312-318
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    proto 5 0
    // contracts/abstracted_account.algo.ts:320
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:320
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:322
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -5
    frame_dig -4
    concat
    // contracts/abstracted_account.algo.ts:323-328
    // const value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(0),
    //   adminPrivileges: adminPrivileges,
    // });
    frame_dig -3
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:326
    // lastCalled: new arc4.UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:323-328
    // const value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(0),
    //   adminPrivileges: adminPrivileges,
    // });
    concat
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:330
    // this.plugins.set(key, value);
    uncover 2
    concat
    swap
    box_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: bytes, allowedCaller: bytes) -> void:
arc58_removePlugin:
    // contracts/abstracted_account.algo.ts:338
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    proto 2 0
    // contracts/abstracted_account.algo.ts:340
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:340
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:342
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -2
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:344
    // this.plugins.delete(key);
    swap
    concat
    box_del
    pop
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: bytes, allowedCaller: bytes, lastValidRound: bytes, cooldown: bytes, adminPrivileges: bytes) -> void:
arc58_addNamedPlugin:
    // contracts/abstracted_account.algo.ts:358-365
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool
    // ): void {
    proto 6 0
    // contracts/abstracted_account.algo.ts:367
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:367
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:368
    // assert(!this.namedPlugins.has(name.native));
    frame_dig -6
    extract 2 0
    // contracts/abstracted_account.algo.ts:40
    // namedPlugins = BoxMap<string, PluginsKey>({ keyPrefix: 'n' });
    bytec 5 // "n"
    // contracts/abstracted_account.algo.ts:368
    // assert(!this.namedPlugins.has(name.native));
    swap
    concat
    dup
    box_len
    bury 1
    !
    assert
    // contracts/abstracted_account.algo.ts:370
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -5
    frame_dig -4
    concat
    // contracts/abstracted_account.algo.ts:371
    // this.namedPlugins.set(name.native, key);
    swap
    dig 1
    box_put
    // contracts/abstracted_account.algo.ts:373-378
    // const value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(0),
    //   adminPrivileges: adminPrivileges,
    // });
    frame_dig -3
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:376
    // lastCalled: new arc4.UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:373-378
    // const value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(0),
    //   adminPrivileges: adminPrivileges,
    // });
    concat
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:380
    // this.plugins.set(key, value);
    uncover 2
    concat
    swap
    box_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // contracts/abstracted_account.algo.ts:388
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    proto 1 0
    // contracts/abstracted_account.algo.ts:390
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // contracts/abstracted_account.algo.ts:27
    // admin = GlobalState<Account>({ key: 'a' });
    intc_0 // 0
    bytec_0 // "a"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:390
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // contracts/abstracted_account.algo.ts:392
    // const key = this.namedPlugins.get(name.native);
    frame_dig -1
    extract 2 0
    // contracts/abstracted_account.algo.ts:40
    // namedPlugins = BoxMap<string, PluginsKey>({ keyPrefix: 'n' });
    bytec 5 // "n"
    // contracts/abstracted_account.algo.ts:392
    // const key = this.namedPlugins.get(name.native);
    swap
    concat
    dup
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:393
    // this.namedPlugins.delete(name.native);
    swap
    box_del
    pop
    // contracts/abstracted_account.algo.ts:35
    // plugins = BoxMap<PluginsKey, PluginInfo>({ keyPrefix: 'p' });
    bytec_2 // "p"
    // contracts/abstracted_account.algo.ts:394
    // this.plugins.delete(key);
    swap
    concat
    box_del
    pop
    retsub
