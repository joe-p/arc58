#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 4 225 400 36500 55400 38500
    bytecblock "p" 0x "controlled_address" "a" 0x00 "admin" "spending_address" 0x0000000000000000 "spend_factory" "n" 0x151f7c75 0x01 0x0f885493 0x0000 0x47c79d5f 0x8a39e79f

main_block@0:

main_block@1:
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txn NumAppArgs
    intc_0 // 0
    !=
    bz main_bare_routing@20

main_abi_routing@2:
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 0
    pushbytes 0xbb139508 // method "createApplication(address,address,application)void"
    pushbytes 0xd24b7556 // method "arc58_changeAdmin(address)void"
    pushbytes 0x5fa449c6 // method "arc58_pluginChangeAdmin(uint64,address,address)void"
    pushbytes 0x13bc44e4 // method "arc58_getAdmin()address"
    bytec 12 // method "arc58_verifyAuthAddr()void"
    pushbytes 0xc95a5d3d // method "arc58_rekeyTo(address,bool)void"
    pushbytes 0x682fdbf8 // method "arc58_canCall(uint64,bool,address,byte[4])bool"
    pushbytes 0xde300fe9 // method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void"
    pushbytes 0xbe39d3c8 // method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void"
    pushbytes 0x9ac5b48d // method "arc58_addPlugin(uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void"
    pushbytes 0x4d372355 // method "arc58_removePlugin(uint64,address)void"
    pushbytes 0x0e1c77d2 // method "arc58_addNamedPlugin(string,uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void"
    pushbytes 0xe350b9d4 // method "arc58_removeNamedPlugin(string)void"
    pushbytes 0x5f08dfc7 // method "arc58_addAllowance(uint64,address,uint64,uint8,uint64,uint64,uint64)void"
    pushbytes 0x3f66056f // method "arc58_removeAllowance(uint64,address,uint64)void"
    uncover 15
    match main_createApplication_route@3 main_arc58_changeAdmin_route@4 main_arc58_pluginChangeAdmin_route@5 main_arc58_getAdmin_route@6 main_arc58_verifyAuthAddr_route@7 main_arc58_rekeyTo_route@8 main_arc58_canCall_route@9 main_arc58_rekeyToPlugin_route@10 main_arc58_rekeyToNamedPlugin_route@11 main_arc58_addPlugin_route@12 main_arc58_removePlugin_route@13 main_arc58_addNamedPlugin_route@14 main_arc58_removeNamedPlugin_route@15 main_arc58_addAllowance_route@16 main_arc58_removeAllowance_route@17

main_switch_case_default@18:

main_switch_case_next@19:

main_after_if_else@21:
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    intc_0 // 0

main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22:
    return

main_arc58_removeAllowance_route@17:
    // contracts/abstracted_account.algo.ts:954
    // arc58_removeAllowance(plugin: uint64, caller: Address, asset: uint64): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    // contracts/abstracted_account.algo.ts:954
    // arc58_removeAllowance(plugin: uint64, caller: Address, asset: uint64): void {
    uncover 2
    uncover 2
    uncover 2
    callsub arc58_removeAllowance
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_addAllowance_route@16:
    // contracts/abstracted_account.algo.ts:906-914
    // arc58_addAllowance(
    //   plugin: uint64,
    //   caller: Address,
    //   asset: uint64,
    //   type: SpendAllowanceType,
    //   allowed: uint64,
    //   max: uint64,
    //   interval: uint64,
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // contracts/abstracted_account.algo.ts:906-914
    // arc58_addAllowance(
    //   plugin: uint64,
    //   caller: Address,
    //   asset: uint64,
    //   type: SpendAllowanceType,
    //   allowed: uint64,
    //   max: uint64,
    //   interval: uint64,
    // ): void {
    uncover 6
    uncover 6
    uncover 6
    uncover 6
    uncover 6
    uncover 6
    uncover 6
    callsub arc58_addAllowance
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_removeNamedPlugin_route@15:
    // contracts/abstracted_account.algo.ts:869
    // arc58_removeNamedPlugin(name: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/abstracted_account.algo.ts:869
    // arc58_removeNamedPlugin(name: string): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_addNamedPlugin_route@14:
    // contracts/abstracted_account.algo.ts:782-793
    // arc58_addNamedPlugin(
    //   name: string,
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    txna ApplicationArgs 9
    intc_0 // 0
    getbit
    txna ApplicationArgs 10
    intc_0 // 0
    getbit
    // contracts/abstracted_account.algo.ts:782-793
    // arc58_addNamedPlugin(
    //   name: string,
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    callsub arc58_addNamedPlugin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_removePlugin_route@13:
    // contracts/abstracted_account.algo.ts:728
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/abstracted_account.algo.ts:728
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    callsub arc58_removePlugin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_addPlugin_route@12:
    // contracts/abstracted_account.algo.ts:637-647
    // arc58_addPlugin(
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    intc_0 // 0
    getbit
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    txna ApplicationArgs 8
    intc_0 // 0
    getbit
    txna ApplicationArgs 9
    intc_0 // 0
    getbit
    // contracts/abstracted_account.algo.ts:637-647
    // arc58_addPlugin(
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    uncover 8
    callsub arc58_addPlugin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_rekeyToNamedPlugin_route@11:
    // contracts/abstracted_account.algo.ts:615
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: DynamicArray<UintN64>, fundsRequest: DynamicArray<arc4FundsRequest>): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // contracts/abstracted_account.algo.ts:615
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: DynamicArray<UintN64>, fundsRequest: DynamicArray<arc4FundsRequest>): void {
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_rekeyToPlugin_route@10:
    // contracts/abstracted_account.algo.ts:554-559
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: DynamicArray<UintN64>,
    //   fundsRequest: DynamicArray<arc4FundsRequest>
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // contracts/abstracted_account.algo.ts:554-559
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: DynamicArray<UintN64>,
    //   fundsRequest: DynamicArray<arc4FundsRequest>
    // ): void {
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    callsub arc58_rekeyToPlugin
    popn 2
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_canCall_route@9:
    // contracts/abstracted_account.algo.ts:532
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // contracts/abstracted_account.algo.ts:532
    // @abimethod({ readonly: true })
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    callsub arc58_canCall
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_rekeyTo_route@8:
    // contracts/abstracted_account.algo.ts:506
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // contracts/abstracted_account.algo.ts:506
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_verifyAuthAddr_route@7:
    // contracts/abstracted_account.algo.ts:495
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_getAdmin_route@6:
    // contracts/abstracted_account.algo.ts:487
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_pluginChangeAdmin_route@5:
    // contracts/abstracted_account.algo.ts:458
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/abstracted_account.algo.ts:458
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    uncover 2
    uncover 2
    uncover 2
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_arc58_changeAdmin_route@4:
    // contracts/abstracted_account.algo.ts:443
    // arc58_changeAdmin(newAdmin: Address): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // contracts/abstracted_account.algo.ts:443
    // arc58_changeAdmin(newAdmin: Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_createApplication_route@3:
    // contracts/abstracted_account.algo.ts:421
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    ==
    assert // can only call when creating
    // contracts/abstracted_account.algo.ts:10
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    txnas Applications
    // contracts/abstracted_account.algo.ts:421
    // @abimethod({ onCreate: 'require' })
    uncover 2
    uncover 2
    uncover 2
    callsub createApplication
    intc_1 // 1
    b main_after_inlined_contracts/abstracted_account.algo.ts::AbstractedAccount.__puya_arc4_router__@22

main_bare_routing@20:
    b main_after_if_else@21


// contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
updateLastUserInteraction:

updateLastUserInteraction_block@0:
    // contracts/abstracted_account.algo.ts:45
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    // contracts/constants.ts:3
    // export const AbstractAccountGlobalStateKeysLastUserInteraction = 'last_user_interaction'
    pushbytes "last_user_interaction"
    // contracts/abstracted_account.algo.ts:45
    // this.lastUserInteraction.value = Global.latestTimestamp
    swap
    app_global_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.updateLastChange() -> void:
updateLastChange:

updateLastChange_block@0:
    // contracts/abstracted_account.algo.ts:49
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    // contracts/constants.ts:4
    // export const AbstractAccountGlobalStateKeysLastChange = 'last_change'
    pushbytes "last_change"
    // contracts/abstracted_account.algo.ts:49
    // this.lastChange.value = Global.latestTimestamp
    swap
    app_global_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(app: uint64, caller: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // contracts/abstracted_account.algo.ts:52
    // private pluginCallAllowed(app: uint64, caller: Account, method: StaticBytes<4>): boolean {
    proto 3 1
    intc_0 // 0
    bytec_1 // ""
    dupn 4

pluginCallAllowed_block@0:
    // contracts/abstracted_account.algo.ts:54
    // application: new UintN64(app),
    frame_dig -3
    itob
    // contracts/abstracted_account.algo.ts:53-56
    // const key = new arc4PluginsKey({
    //   application: new UintN64(app),
    //   allowedCaller: new Address(caller)
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -2
    concat
    dup
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/abstracted_account.algo.ts:58
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2

pluginCallAllowed_if_body@1:
    // contracts/abstracted_account.algo.ts:59
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 6
    concat
    // contracts/abstracted_account.algo.ts:62
    // const methods = this.plugins(key).value.methods.copy();
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    dup
    frame_bury 0
    // contracts/abstracted_account.algo.ts:63
    // let methodAllowed = methods.length > 0 ? false : true;
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    intc_1 // 1
    intc_0 // 0
    uncover 2
    select
    frame_bury 3
    // contracts/abstracted_account.algo.ts:64
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@3:
    // contracts/abstracted_account.algo.ts:64
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 0
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz pluginCallAllowed_after_while@7

pluginCallAllowed_while_body@4:
    // contracts/abstracted_account.algo.ts:65
    // if (methods[i].selector === method) {
    frame_dig 0
    extract 2 0
    frame_dig 2
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    intc_0 // 0
    intc_3 // 4
    extract3 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@6

pluginCallAllowed_if_body@5:
    // contracts/abstracted_account.algo.ts:66
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 3

pluginCallAllowed_block@8:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 6
    concat
    // contracts/abstracted_account.algo.ts:71
    // const p = decodeArc4<PluginInfo>(this.plugins(key).value.copy().bytes);
    box_get
    assert // Box must have value
    dup
    pushint 18 // 18
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    pushint 29 // 29
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    uncover 2
    frame_bury 4
    frame_bury 5
    // contracts/abstracted_account.algo.ts:72
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCallAllowed_ternary_false@10

pluginCallAllowed_ternary_true@9:
    // contracts/abstracted_account.algo.ts:72
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    global Round

pluginCallAllowed_ternary_merge@11:
    // contracts/abstracted_account.algo.ts:72
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    dup
    frame_bury 1
    // contracts/abstracted_account.algo.ts:75
    // p.lastCalled >= epochRef &&
    frame_dig 5
    <=
    // contracts/abstracted_account.algo.ts:75-76
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    bz pluginCallAllowed_bool_false@14

pluginCallAllowed_and_contd@12:
    // contracts/abstracted_account.algo.ts:76
    // (epochRef - p.lastCalled) >= p.cooldown &&
    frame_dig 1
    frame_dig 5
    -
    frame_dig 4
    >=
    // contracts/abstracted_account.algo.ts:75-76
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    bz pluginCallAllowed_bool_false@14

pluginCallAllowed_bool_true@13:
    intc_1 // 1

pluginCallAllowed_bool_merge@15:
    // contracts/abstracted_account.algo.ts:75-77
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    // methodAllowed
    frame_dig 3
    &&
    // contracts/abstracted_account.algo.ts:74-78
    // return (
    //   p.lastCalled >= epochRef &&
    //   (epochRef - p.lastCalled) >= p.cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@14:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@15

pluginCallAllowed_ternary_false@10:
    // contracts/abstracted_account.algo.ts:72
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCallAllowed_ternary_merge@11

pluginCallAllowed_after_if_else@6:
    // contracts/abstracted_account.algo.ts:64
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@3

pluginCallAllowed_after_while@7:
    b pluginCallAllowed_block@8


// contracts/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // contracts/abstracted_account.algo.ts:81
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1

txnRekeysBack_block@0:
    // contracts/abstracted_account.algo.ts:84
    // txn.sender === this.controlledAddress.value &&
    frame_dig -1
    gtxns Sender
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:84
    // txn.sender === this.controlledAddress.value &&
    ==
    // contracts/abstracted_account.algo.ts:84-85
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3

txnRekeysBack_and_contd@1:
    // contracts/abstracted_account.algo.ts:85
    // txn.rekeyTo === Global.currentApplicationAddress
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    // contracts/abstracted_account.algo.ts:84-85
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3

txnRekeysBack_if_body@2:
    // contracts/abstracted_account.algo.ts:87
    // return true;
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // contracts/abstracted_account.algo.ts:91
    // txn.type === TransactionType.ApplicationCall
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // contracts/abstracted_account.algo.ts:91-92
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@4:
    // contracts/abstracted_account.algo.ts:92
    // && txn.appId === Global.currentApplicationId
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // contracts/abstracted_account.algo.ts:91-92
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@5:
    // contracts/abstracted_account.algo.ts:93
    // && txn.numAppArgs === 1
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // contracts/abstracted_account.algo.ts:91-93
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@6:
    // contracts/abstracted_account.algo.ts:94
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig -1
    gtxns OnCompletion
    intc_0 // 0
    ==
    // contracts/abstracted_account.algo.ts:91-94
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@7:
    // contracts/abstracted_account.algo.ts:95
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 12 // method "arc58_verifyAuthAddr()void"
    ==
    // contracts/abstracted_account.algo.ts:91-95
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    bz txnRekeysBack_bool_false@9

txnRekeysBack_bool_true@8:
    intc_1 // 1

txnRekeysBack_bool_merge@10:
    // contracts/abstracted_account.algo.ts:90-96
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    b txnRekeysBack_bool_merge@10


// contracts/abstracted_account.algo.ts::AbstractedAccount.assertRekeysBack() -> void:
assertRekeysBack:
    // contracts/abstracted_account.algo.ts:99
    // private assertRekeysBack(): void {
    proto 0 0

assertRekeysBack_block@0:
    // contracts/abstracted_account.algo.ts:100
    // let rekeysBack = false;
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:101
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +

assertRekeysBack_while_top@1:
    // contracts/abstracted_account.algo.ts:101
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    global GroupSize
    frame_dig 1
    >
    bz assertRekeysBack_after_while@5

assertRekeysBack_while_body@2:
    // contracts/abstracted_account.algo.ts:102
    // const txn = gtxn.Transaction(i)
    frame_dig 1
    // contracts/abstracted_account.algo.ts:104
    // if (this.txnRekeysBack(txn)) {
    callsub txnRekeysBack
    bz assertRekeysBack_after_if_else@4

assertRekeysBack_if_body@3:
    // contracts/abstracted_account.algo.ts:105
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 0

assertRekeysBack_block@6:
    // contracts/abstracted_account.algo.ts:110
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 0
    assert // missing rekey back
    retsub

assertRekeysBack_after_if_else@4:
    // contracts/abstracted_account.algo.ts:101
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b assertRekeysBack_while_top@1

assertRekeysBack_after_while@5:
    b assertRekeysBack_block@6


// contracts/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64, bytes:
pluginCheck:
    // contracts/abstracted_account.algo.ts:113
    // private pluginCheck(key: arc4PluginsKey): PluginValidation {
    proto 1 7
    intc_0 // 0
    bytec_1 // ""
    dupn 6

pluginCheck_block@0:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:115
    // const exists = this.plugins(key).exists;
    box_len
    bury 1
    dup
    // contracts/abstracted_account.algo.ts:116
    // if (!exists) {
    bnz pluginCheck_after_if_else@2

pluginCheck_if_body@1:
    // contracts/abstracted_account.algo.ts:118
    // exists: false,
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:119
    // expired: true,
    intc_1 // 1
    // contracts/abstracted_account.algo.ts:120-121
    // hasCooldown: true,
    // onCooldown: true,
    dupn 2
    // contracts/abstracted_account.algo.ts:122
    // hasMethodRestrictions: false,
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:123
    // valid: false
    dup
    // contracts/abstracted_account.algo.ts:117-124
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    frame_dig -1
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_after_if_else@2:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:127
    // const pluginInfo = decodeArc4<PluginInfo>(this.plugins(key).value.copy().bytes);
    box_get
    assert // Box must have value
    dup
    pushint 10 // 10
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    pushint 18 // 18
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    dup
    uncover 3
    uncover 3
    substring3
    swap
    dup
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    pushint 29 // 29
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    uncover 4
    frame_bury 7
    uncover 3
    frame_bury 5
    uncover 2
    frame_bury 0
    frame_bury 6
    // contracts/abstracted_account.algo.ts:128
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCheck_ternary_false@4

pluginCheck_ternary_true@3:
    // contracts/abstracted_account.algo.ts:128
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp;
    global Round

pluginCheck_ternary_merge@5:
    // contracts/abstracted_account.algo.ts:130
    // const expired = epochRef > pluginInfo.lastValid;
    dup
    frame_dig 7
    >
    frame_bury 1
    // contracts/abstracted_account.algo.ts:131
    // const hasCooldown = pluginInfo.cooldown > 0;
    frame_dig 5
    dup
    cover 2
    intc_0 // 0
    >
    frame_bury 2
    // contracts/abstracted_account.algo.ts:132
    // const onCooldown = (epochRef - pluginInfo.lastCalled) < pluginInfo.cooldown;
    frame_dig 6
    -
    >
    frame_bury 4
    // contracts/abstracted_account.algo.ts:133
    // const hasMethodRestrictions = pluginInfo.methods.length > 0;
    frame_dig 0
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    frame_bury 3
    // contracts/abstracted_account.algo.ts:135
    // const valid = exists && !expired && !onCooldown;
    frame_dig 8
    bz pluginCheck_bool_false@9

pluginCheck_and_contd@6:
    // contracts/abstracted_account.algo.ts:135
    // const valid = exists && !expired && !onCooldown;
    frame_dig 1
    bnz pluginCheck_bool_false@9

pluginCheck_and_contd@7:
    // contracts/abstracted_account.algo.ts:135
    // const valid = exists && !expired && !onCooldown;
    frame_dig 4
    bnz pluginCheck_bool_false@9

pluginCheck_bool_true@8:
    intc_1 // 1

pluginCheck_bool_merge@10:
    // contracts/abstracted_account.algo.ts:137-144
    // return {
    //   exists,
    //   expired,
    //   hasCooldown,
    //   onCooldown,
    //   hasMethodRestrictions,
    //   valid
    // }
    frame_dig 8
    frame_dig 1
    frame_dig 2
    frame_dig 4
    frame_dig 3
    uncover 5
    frame_dig -1
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_bool_false@9:
    intc_0 // 0
    b pluginCheck_bool_merge@10

pluginCheck_ternary_false@4:
    // contracts/abstracted_account.algo.ts:128
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCheck_ternary_merge@5


// contracts/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key: bytes, txn: uint64, methodOffsets: bytes, methodIndex: uint64) -> uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, bytes, bytes:
fullPluginCheck:
    // contracts/abstracted_account.algo.ts:147-152
    // private fullPluginCheck(
    //   key: arc4PluginsKey,
    //   txn: gtxn.ApplicationCallTxn,
    //   methodOffsets: DynamicArray<UintN64>,
    //   methodIndex: uint64
    // ): FullPluginValidation {
    proto 4 11
    intc_0 // 0
    bytec_1 // ""
    dupn 11

fullPluginCheck_block@0:
    // contracts/abstracted_account.algo.ts:154
    // const check = this.pluginCheck(key);
    frame_dig -4
    callsub pluginCheck
    cover 6
    cover 6
    cover 5
    cover 4
    cover 3
    cover 2
    swap
    frame_bury -4
    intc_1 // 1
    bz fullPluginCheck_after_if_else@2

fullPluginCheck_if_body@1:

fullPluginCheck_after_if_else@2:
    // contracts/abstracted_account.algo.ts:154
    // const check = this.pluginCheck(key);
    frame_dig 18
    frame_bury 1
    frame_dig 17
    frame_bury 2
    frame_dig 16
    frame_bury 3
    frame_dig 15
    frame_bury 5
    frame_dig 14
    frame_bury 4
    frame_dig 13
    dup
    frame_bury 6
    // contracts/abstracted_account.algo.ts:156
    // if (!check.valid) {
    bnz fullPluginCheck_after_if_else@4

fullPluginCheck_if_body@3:
    // contracts/abstracted_account.algo.ts:157-162
    // return {
    //   ...check,
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    frame_dig 1
    frame_dig 2
    frame_dig 3
    frame_dig 5
    frame_dig 4
    // contracts/abstracted_account.algo.ts:159
    // methodAllowed: false,
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:160
    // methodHasCooldown: true,
    intc_1 // 1
    // contracts/abstracted_account.algo.ts:161
    // methodOnCooldown: true
    dup
    // contracts/abstracted_account.algo.ts:157-162
    // return {
    //   ...check,
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    frame_dig 6
    frame_dig -4
    frame_dig -2
    frame_bury 10
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_after_if_else@4:
    // contracts/abstracted_account.algo.ts:166
    // methodAllowed: !check.hasMethodRestrictions,
    frame_dig 4
    dup
    !
    // contracts/abstracted_account.algo.ts:165-169
    // let mCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 7
    // contracts/abstracted_account.algo.ts:167
    // methodHasCooldown: false,
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:165-169
    // let mCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 8
    // contracts/abstracted_account.algo.ts:168
    // methodOnCooldown: false
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:165-169
    // let mCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 9
    frame_dig -4
    frame_bury 0
    // contracts/abstracted_account.algo.ts:171
    // if (check.hasMethodRestrictions) {
    bz fullPluginCheck_after_if_else@8

fullPluginCheck_if_body@5:
    // contracts/abstracted_account.algo.ts:172
    // assert(methodIndex < methodOffsets.length, ERR_MALFORMED_OFFSETS);
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig -1
    >
    assert // malformed method offsets
    // contracts/abstracted_account.algo.ts:173
    // mCheck = this.methodCheck(key, txn, methodOffsets[methodIndex].native);
    frame_dig -2
    extract 2 0
    frame_dig -1
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -4
    frame_dig -3
    uncover 2
    callsub methodCheck
    cover 3
    frame_bury 12
    frame_bury 11
    frame_bury 10
    frame_bury -4
    intc_1 // 1
    bz fullPluginCheck_after_if_else@7

fullPluginCheck_if_body@6:

fullPluginCheck_after_if_else@7:
    // contracts/abstracted_account.algo.ts:173
    // mCheck = this.methodCheck(key, txn, methodOffsets[methodIndex].native);
    frame_dig 10
    frame_bury 7
    frame_dig 11
    frame_bury 8
    frame_dig 12
    frame_bury 9
    frame_dig -4
    frame_bury 0

fullPluginCheck_after_if_else@8:
    frame_dig 0
    frame_bury -4
    // contracts/abstracted_account.algo.ts:179
    // valid: check.valid && mCheck.methodAllowed
    frame_dig 6
    bz fullPluginCheck_bool_false@11

fullPluginCheck_and_contd@9:
    // contracts/abstracted_account.algo.ts:179
    // valid: check.valid && mCheck.methodAllowed
    frame_dig 7
    bz fullPluginCheck_bool_false@11

fullPluginCheck_bool_true@10:
    intc_1 // 1

fullPluginCheck_bool_merge@12:
    // contracts/abstracted_account.algo.ts:176-180
    // return {
    //   ...check,
    //   ...mCheck,
    //   valid: check.valid && mCheck.methodAllowed
    // }
    frame_dig 1
    frame_dig 2
    frame_dig 3
    frame_dig 5
    frame_dig 4
    frame_dig 7
    frame_dig 8
    frame_dig 9
    uncover 8
    frame_dig -4
    frame_dig -2
    frame_bury 10
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_bool_false@11:
    intc_0 // 0
    b fullPluginCheck_bool_merge@12


// contracts/abstracted_account.algo.ts::AbstractedAccount.assertValidGroup(key: bytes, methodOffsets: bytes) -> bytes, bytes:
assertValidGroup:
    // contracts/abstracted_account.algo.ts:189
    // private assertValidGroup(key: arc4PluginsKey, methodOffsets: DynamicArray<UintN64>): void {
    proto 2 2
    intc_0 // 0
    bytec_1 // ""
    dupn 11

assertValidGroup_block@0:
    frame_dig -2
    frame_dig -1
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:191
    // const epochRef = this.plugins(key).value.useRounds.native
    box_get
    assert // Box must have value
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // contracts/abstracted_account.algo.ts:191-193
    // const epochRef = this.plugins(key).value.useRounds.native
    //   ? Global.round
    //   : Global.latestTimestamp;
    bz assertValidGroup_ternary_false@2

assertValidGroup_ternary_true@1:
    // contracts/abstracted_account.algo.ts:192
    // ? Global.round
    global Round

assertValidGroup_ternary_merge@3:
    // contracts/abstracted_account.algo.ts:191-193
    // const epochRef = this.plugins(key).value.useRounds.native
    //   ? Global.round
    //   : Global.latestTimestamp;
    frame_bury 1
    // contracts/abstracted_account.algo.ts:195
    // const initialCheck = this.pluginCheck(key);
    frame_dig -2
    callsub pluginCheck
    cover 6
    popn 2
    frame_bury 10
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury -2
    intc_1 // 1
    bz assertValidGroup_after_if_else@5

assertValidGroup_if_body@4:
    frame_dig -2
    frame_bury 13

assertValidGroup_after_if_else@5:
    // contracts/abstracted_account.algo.ts:195
    // const initialCheck = this.pluginCheck(key);
    frame_dig 7
    frame_dig 8
    swap
    frame_dig 9
    frame_bury 5
    frame_dig 10
    cover 2
    // contracts/abstracted_account.algo.ts:197
    // assert(initialCheck.exists, ERR_PLUGIN_DOES_NOT_EXIST);
    assert // plugin does not exist
    // contracts/abstracted_account.algo.ts:198
    // assert(!initialCheck.expired, ERR_PLUGIN_EXPIRED);
    !
    assert // plugin expired
    // contracts/abstracted_account.algo.ts:199
    // assert(!initialCheck.onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    !
    assert // plugin on cooldown
    // contracts/abstracted_account.algo.ts:201
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 11
    // contracts/abstracted_account.algo.ts:202
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 6
    // contracts/abstracted_account.algo.ts:204
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 4

assertValidGroup_while_top@6:
    // contracts/abstracted_account.algo.ts:204
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    global GroupSize
    frame_dig 4
    >
    bz assertValidGroup_after_while@19

assertValidGroup_while_body@7:
    // contracts/abstracted_account.algo.ts:205
    // const txn = gtxn.Transaction(i)
    frame_dig 4
    dup
    frame_bury 12
    // contracts/abstracted_account.algo.ts:207
    // if (this.txnRekeysBack(txn)) {
    callsub txnRekeysBack
    bz assertValidGroup_after_if_else@9

assertValidGroup_if_body@8:
    // contracts/abstracted_account.algo.ts:208
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 11

assertValidGroup_block@20:
    // contracts/abstracted_account.algo.ts:235
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 11
    assert // missing rekey back
    frame_dig 13
    frame_dig 14
    frame_bury 1
    frame_bury 0
    retsub

assertValidGroup_after_if_else@9:
    // contracts/abstracted_account.algo.ts:212
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 12
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bz assertValidGroup_after_if_else@11

assertValidGroup_if_body@10:

assertValidGroup_block@18:
    // contracts/abstracted_account.algo.ts:204
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b assertValidGroup_while_top@6

assertValidGroup_after_if_else@11:
    // contracts/abstracted_account.algo.ts:216
    // assert(txn.appId.id === key.application.native, ERR_CANNOT_CALL_OTHER_APPS_DURING_REKEY);
    frame_dig 12
    dup
    gtxns ApplicationID
    frame_dig -2
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    ==
    assert // cannot call other apps during rekey
    // contracts/abstracted_account.algo.ts:217
    // assert(txn.onCompletion === OnCompleteAction.NoOp, ERR_INVALID_ONCOMPLETE);
    dup
    gtxns OnCompletion
    intc_0 // 0
    ==
    assert // invalid oncomplete must be no op
    // contracts/abstracted_account.algo.ts:220
    // assert(txn.numAppArgs > 1, ERR_INVALID_SENDER_ARG);
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // invalid sender must be this app id
    // contracts/abstracted_account.algo.ts:221
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, ERR_INVALID_SENDER_VALUE);
    dup
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // invalid sender app id
    // contracts/abstracted_account.algo.ts:223
    // const check = this.fullPluginCheck(key, txn, methodOffsets, methodIndex);
    frame_dig -2
    swap
    frame_dig -1
    frame_dig 6
    callsub fullPluginCheck
    cover 10
    frame_bury 0
    frame_bury 3
    frame_bury 2
    popn 7
    frame_bury -1
    intc_1 // 1
    bz assertValidGroup_after_if_else@13

assertValidGroup_if_body@12:
    frame_dig -1
    frame_bury 14

assertValidGroup_after_if_else@13:
    // contracts/abstracted_account.algo.ts:223
    // const check = this.fullPluginCheck(key, txn, methodOffsets, methodIndex);
    frame_dig 0
    frame_bury -2
    intc_1 // 1
    bz assertValidGroup_after_if_else@15

assertValidGroup_if_body@14:
    frame_dig -2
    frame_bury 13

assertValidGroup_after_if_else@15:
    // contracts/abstracted_account.algo.ts:223
    // const check = this.fullPluginCheck(key, txn, methodOffsets, methodIndex);
    frame_dig 2
    frame_dig 3
    swap
    // contracts/abstracted_account.algo.ts:225
    // assert(!check.methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    !
    assert // method on cooldown
    // contracts/abstracted_account.algo.ts:226
    // assert(check.valid, ERR_INVALID_PLUGIN_CALL);
    assert // invalid plugin call
    // contracts/abstracted_account.algo.ts:228
    // if (initialCheck.hasCooldown) {
    frame_dig 5
    bz assertValidGroup_after_if_else@17

assertValidGroup_if_body@16:
    // contracts/abstracted_account.algo.ts:229
    // this.plugins(key).value.lastCalled = new UintN64(epochRef)
    frame_dig 1
    itob
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:229
    // this.plugins(key).value.lastCalled = new UintN64(epochRef)
    dup
    box_get
    assert // Box must have value
    uncover 2
    swap
    pushint 29 // 29
    uncover 2
    replace3
    dig 1
    box_del
    pop
    box_put

assertValidGroup_after_if_else@17:
    // contracts/abstracted_account.algo.ts:232
    // methodIndex += 1;
    frame_dig 6
    intc_1 // 1
    +
    frame_bury 6
    b assertValidGroup_block@18

assertValidGroup_after_while@19:
    b assertValidGroup_block@20

assertValidGroup_ternary_false@2:
    // contracts/abstracted_account.algo.ts:193
    // : Global.latestTimestamp;
    global LatestTimestamp
    b assertValidGroup_ternary_merge@3


// contracts/abstracted_account.algo.ts::AbstractedAccount.methodCheck(key: bytes, txn: uint64, offset: uint64) -> uint64, uint64, uint64, bytes:
methodCheck:
    // contracts/abstracted_account.algo.ts:246
    // private methodCheck(key: arc4PluginsKey, txn: gtxn.ApplicationCallTxn, offset: uint64): MethodValidation {
    proto 3 4
    bytec_1 // ""

methodCheck_block@0:
    // contracts/abstracted_account.algo.ts:248
    // assert(len(txn.appArgs(0)) === 4, ERR_INVALID_METHOD_SIGNATURE_LENGTH);
    frame_dig -2
    intc_0 // 0
    gtxnsas ApplicationArgs
    len
    intc_3 // 4
    ==
    assert // invalid method signature length
    // contracts/abstracted_account.algo.ts:249
    // const selectorArg = new StaticBytes<4>(txn.appArgs(0));
    frame_dig -2
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    len
    intc_3 // 4
    ==
    assert // invalid size
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:251
    // const methods = this.plugins(key).value.methods.copy()
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    dup
    // contracts/abstracted_account.algo.ts:252
    // const allowedMethod = methods[offset].copy();
    extract 2 0
    frame_dig -1
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    dup
    // contracts/abstracted_account.algo.ts:254
    // const hasCooldown = allowedMethod.cooldown.native > 0;
    intc_3 // 4
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    intc_0 // 0
    >
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:256
    // const useRounds = this.plugins(key).value.useRounds.native
    box_get
    assert // Box must have value
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dup
    // contracts/abstracted_account.algo.ts:258
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    bz methodCheck_ternary_false@2

methodCheck_ternary_true@1:
    // contracts/abstracted_account.algo.ts:258
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

methodCheck_ternary_merge@3:
    // contracts/abstracted_account.algo.ts:259
    // const onCooldown = (epochRef - allowedMethod.lastCalled.native) < allowedMethod.cooldown.native;
    frame_dig 3
    dup
    cover 2
    pushint 12 // 12
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    -
    dig 1
    intc_3 // 4
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    <
    frame_bury 0
    // contracts/abstracted_account.algo.ts:261
    // if (allowedMethod.selector === selectorArg && (!hasCooldown || !onCooldown)) {
    intc_0 // 0
    intc_3 // 4
    extract3 // on error: Index access is out of bounds
    frame_dig 1
    ==
    bz methodCheck_after_if_else@12

methodCheck_and_contd@4:
    // contracts/abstracted_account.algo.ts:261
    // if (allowedMethod.selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 4
    bz methodCheck_if_body@6

methodCheck_or_contd@5:
    // contracts/abstracted_account.algo.ts:261
    // if (allowedMethod.selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 0
    bnz methodCheck_after_if_else@12

methodCheck_if_body@6:
    // contracts/abstracted_account.algo.ts:263
    // if (hasCooldown) {
    frame_dig 4
    bz methodCheck_after_if_else@11

methodCheck_if_body@7:
    // contracts/abstracted_account.algo.ts:264-266
    // const lastCalled = useRounds
    //   ? new UintN64(Global.round)
    //   : new UintN64(Global.latestTimestamp);
    frame_dig 5
    bz methodCheck_ternary_false@9

methodCheck_ternary_true@8:
    // contracts/abstracted_account.algo.ts:265
    // ? new UintN64(Global.round)
    global Round
    itob

methodCheck_ternary_merge@10:
    // contracts/abstracted_account.algo.ts:268
    // methods[offset].lastCalled = lastCalled;
    frame_dig 2
    dup
    cover 2
    extract 2 0
    frame_dig -1
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    pushint 12 // 12
    uncover 2
    replace3
    swap
    dup
    intc_0 // 0
    extract_uint16
    frame_dig -1
    >
    assert // Index access is out of bounds
    frame_dig -1
    pushint 20 // 20
    *
    pushint 2 // 2
    +
    uncover 2
    replace3
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    intc_0 // 0
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    intc_1 // 1
    dup
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 2 // 2
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 10 // 10
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 18 // 18
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 224 // 224
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 29 // 29
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    pushint 37 // 37
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    pushint 45 // 45
    itob
    extract 6 2
    concat
    uncover 4
    concat
    uncover 3
    intc_0 // 0
    getbit
    swap
    intc 4 // 225
    uncover 2
    setbit
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new arc4PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    dup
    box_del
    pop
    swap
    box_put

methodCheck_after_if_else@11:
    // contracts/abstracted_account.algo.ts:277
    // methodAllowed: true,
    intc_1 // 1
    // contracts/abstracted_account.algo.ts:276-280
    // return {
    //   methodAllowed: true,
    //   methodHasCooldown: hasCooldown,
    //   methodOnCooldown: onCooldown
    // }
    frame_dig 4
    frame_dig 0
    frame_dig -3
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

methodCheck_ternary_false@9:
    // contracts/abstracted_account.algo.ts:266
    // : new UintN64(Global.latestTimestamp);
    global LatestTimestamp
    itob
    b methodCheck_ternary_merge@10

methodCheck_after_if_else@12:
    // contracts/abstracted_account.algo.ts:284
    // methodAllowed: false,
    intc_0 // 0
    // contracts/abstracted_account.algo.ts:285
    // methodHasCooldown: true,
    intc_1 // 1
    // contracts/abstracted_account.algo.ts:286
    // methodOnCooldown: true
    dup
    // contracts/abstracted_account.algo.ts:283-287
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    frame_dig -3
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

methodCheck_ternary_false@2:
    // contracts/abstracted_account.algo.ts:258
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b methodCheck_ternary_merge@3


// contracts/abstracted_account.algo.ts::AbstractedAccount.transferFunds(key: bytes, fundsRequests: bytes) -> bytes, bytes:
transferFunds:
    // contracts/abstracted_account.algo.ts:290
    // private transferFunds(key: arc4PluginsKey, fundsRequests: DynamicArray<arc4FundsRequest>): void {
    proto 2 2
    bytec_1 // ""

transferFunds_block@0:
    frame_dig -2
    frame_dig -1
    // contracts/abstracted_account.algo.ts:291
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0

transferFunds_while_top@1:
    // contracts/abstracted_account.algo.ts:291
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz transferFunds_after_while@8

transferFunds_while_body@2:
    // contracts/abstracted_account.algo.ts:292
    // const request = decodeArc4<FundsRequest>(fundsRequests[i].bytes)
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    intc_2 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    cover 2
    frame_bury 0
    dup
    cover 2
    cover 2
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:293
    // const pluginInfo = decodeArc4<PluginInfo>(this.plugins(key).value.copy().bytes);
    box_get
    assert // Box must have value
    dup
    intc 4 // 225
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    pushint 37 // 37
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    // contracts/abstracted_account.algo.ts:296
    // allowedCaller: key.allowedCaller,
    frame_dig -2
    intc_2 // 8
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    // contracts/abstracted_account.algo.ts:297
    // application: key.application,
    frame_dig -2
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/abstracted_account.algo.ts:298
    // asset: new UintN64(request.asset)
    dig 4
    itob
    swap
    // contracts/abstracted_account.algo.ts:295-299
    // const allowanceKey = new arc4AllowanceKey({
    //   allowedCaller: key.allowedCaller,
    //   application: key.application,
    //   asset: new UintN64(request.asset)
    // });
    bytec_1 // 0x
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:301-306
    // this.verifyAllowance(
    //   pluginInfo.start,
    //   pluginInfo.useRounds,
    //   allowanceKey,
    //   request
    // );
    swap
    uncover 2
    uncover 2
    dig 3
    uncover 5
    callsub verifyAllowance
    pop
    // contracts/abstracted_account.algo.ts:308
    // if (request.asset !== 0) {
    intc_0 // 0
    !=
    bz transferFunds_else_body@5

transferFunds_if_body@3:
    // contracts/abstracted_account.algo.ts:309-317
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: request.amount,
    //     xferAsset: request.asset,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:292
    // const request = decodeArc4<FundsRequest>(fundsRequests[i].bytes)
    uncover 2
    frame_dig 0
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:309-316
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: request.amount,
    //     xferAsset: request.asset,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:315
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

transferFunds_next_txn@4:
    // contracts/abstracted_account.algo.ts:309-317
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: request.amount,
    //     xferAsset: request.asset,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

transferFunds_after_if_else@7:
    // contracts/abstracted_account.algo.ts:291
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b transferFunds_while_top@1

transferFunds_else_body@5:
    // contracts/abstracted_account.algo.ts:319-326
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: request.amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:292
    // const request = decodeArc4<FundsRequest>(fundsRequests[i].bytes)
    uncover 2
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:319-325
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: request.amount,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:324
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

transferFunds_next_txn@6:
    // contracts/abstracted_account.algo.ts:319-326
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: request.amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    b transferFunds_after_if_else@7

transferFunds_after_while@8:
    frame_dig 1
    frame_dig 2
    frame_bury 1
    frame_bury 0
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.verifyAllowance(start: uint64, useRounds: uint64, key: bytes, fundRequest.asset: uint64, fundRequest.amount: uint64) -> bytes:
verifyAllowance:
    // contracts/abstracted_account.algo.ts:331-336
    // private verifyAllowance(
    //   start: uint64,
    //   useRounds: boolean,
    //   key: arc4AllowanceKey,
    //   fundRequest: FundsRequest
    // ): void {
    proto 5 1
    intc_0 // 0
    bytec_1 // ""

verifyAllowance_block@0:
    frame_dig -3
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:337
    // assert(this.allowances(key).exists, 'Allowance does not exist');
    box_len
    bury 1
    assert // Allowance does not exist
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:338
    // const { type, spent, allowed, last, max, interval } = decodeArc4<AllowanceInfo>(this.allowances(key).value.copy().bytes);
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    cover 2
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    pushint 17 // 17
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    cover 2
    pushint 33 // 33
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    uncover 4
    cover 5
    swap
    cover 4
    uncover 2
    cover 3
    cover 2
    // contracts/abstracted_account.algo.ts:339-341
    // const arc4EpochRef = useRounds
    //   ? new UintN64(Global.round)
    //   : new UintN64(Global.latestTimestamp)
    frame_dig -4
    bz verifyAllowance_ternary_false@2

verifyAllowance_ternary_true@1:
    // contracts/abstracted_account.algo.ts:340
    // ? new UintN64(Global.round)
    global Round
    itob

verifyAllowance_ternary_merge@3:
    // contracts/abstracted_account.algo.ts:339-341
    // const arc4EpochRef = useRounds
    //   ? new UintN64(Global.round)
    //   : new UintN64(Global.latestTimestamp)
    frame_bury 0
    // contracts/abstracted_account.algo.ts:343
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 3
    // contracts/types.ts:21
    // export const SpendAllowanceTypeFlat: SpendAllowanceType = new UintN8(1)
    bytec 11 // 0x01
    // contracts/abstracted_account.algo.ts:343
    // if (type === SpendAllowanceTypeFlat) {
    ==
    bz verifyAllowance_else_body@5

verifyAllowance_if_body@4:
    // contracts/abstracted_account.algo.ts:344
    // const leftover: uint64 = allowed - spent;
    frame_dig 5
    frame_dig 4
    dup
    cover 2
    -
    // contracts/abstracted_account.algo.ts:345
    // const amount = fundRequest.amount
    frame_dig -1
    // contracts/abstracted_account.algo.ts:347
    // assert(leftover >= amount, 'Allowance exceeded');
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // contracts/abstracted_account.algo.ts:349
    // this.allowances(key).value.spent = new UintN64(spent + amount);
    +
    itob
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:349
    // this.allowances(key).value.spent = new UintN64(spent + amount);
    dup
    box_get
    assert // Box must have value
    uncover 2
    swap
    pushint 17 // 17
    uncover 2
    replace3
    box_put

verifyAllowance_after_if_else@17:
    frame_dig 2
    frame_bury 0
    retsub

verifyAllowance_else_body@5:
    // contracts/abstracted_account.algo.ts:350
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 3
    // contracts/types.ts:22
    // export const SpendAllowanceTypeWindow: SpendAllowanceType = new UintN8(2)
    pushbytes 0x02
    // contracts/abstracted_account.algo.ts:350
    // } else if (type === SpendAllowanceTypeWindow) {
    ==
    bz verifyAllowance_else_body@10

verifyAllowance_if_body@6:
    // contracts/abstracted_account.algo.ts:351
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    frame_dig -4
    frame_dig -5
    frame_dig 8
    callsub getLatestWindowStart
    // contracts/abstracted_account.algo.ts:352
    // const amount = fundRequest.amount
    frame_dig -1
    frame_bury 1
    // contracts/abstracted_account.algo.ts:354
    // if (currentWindowStart > last) {
    frame_dig 6
    >
    bz verifyAllowance_else_body@8

verifyAllowance_if_body@7:
    // contracts/abstracted_account.algo.ts:355
    // assert(allowed >= amount, 'Allowance exceeded');
    frame_dig 5
    frame_dig 1
    >=
    assert // Allowance exceeded

verifyAllowance_after_if_else@9:
    // contracts/abstracted_account.algo.ts:362
    // const newSpent = new UintN64(spent + amount);
    frame_dig 4
    frame_dig 1
    +
    itob
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:365
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:364-368
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: newSpent,
    //   last: arc4EpochRef
    // })
    intc_0 // 0
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:365
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:364-368
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: newSpent,
    //   last: arc4EpochRef
    // })
    intc_1 // 1
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:365
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:364-368
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: newSpent,
    //   last: arc4EpochRef
    // })
    pushint 9 // 9
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:365
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:364-368
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: newSpent,
    //   last: arc4EpochRef
    // })
    pushint 25 // 25
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 0
    concat
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:364-368
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: newSpent,
    //   last: arc4EpochRef
    // })
    swap
    box_put

verifyAllowance_after_if_else@16:
    b verifyAllowance_after_if_else@17

verifyAllowance_else_body@8:
    // contracts/abstracted_account.algo.ts:358
    // const leftover: uint64 = allowed - spent;
    frame_dig 5
    frame_dig 4
    -
    // contracts/abstracted_account.algo.ts:359
    // assert(leftover >= amount, 'Allowance exceeded');
    frame_dig 1
    >=
    assert // Allowance exceeded
    b verifyAllowance_after_if_else@9

verifyAllowance_else_body@10:
    // contracts/abstracted_account.algo.ts:370
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 3
    // contracts/types.ts:23
    // export const SpendAllowanceTypeDrip: SpendAllowanceType = new UintN8(3)
    pushbytes 0x03
    // contracts/abstracted_account.algo.ts:370
    // } else if (type === SpendAllowanceTypeDrip) {
    ==
    bz verifyAllowance_after_if_else@15

verifyAllowance_if_body@11:
    // contracts/abstracted_account.algo.ts:371
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -4
    bz verifyAllowance_ternary_false@13

verifyAllowance_ternary_true@12:
    // contracts/abstracted_account.algo.ts:371
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

verifyAllowance_ternary_merge@14:
    // contracts/abstracted_account.algo.ts:373
    // const amount = fundRequest.amount
    frame_dig -1
    swap
    // contracts/abstracted_account.algo.ts:374
    // const accrualRate = allowed
    frame_dig 5
    swap
    // contracts/abstracted_account.algo.ts:375
    // const lastLeftover = spent
    frame_dig 4
    cover 2
    // contracts/abstracted_account.algo.ts:377
    // const passed: uint64 = epochRef - last
    frame_dig 6
    -
    // contracts/abstracted_account.algo.ts:378
    // const accrued: uint64 = lastLeftover + ((passed / interval) * accrualRate)
    frame_dig 8
    /
    *
    +
    // contracts/abstracted_account.algo.ts:380
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 7
    dup
    cover 3
    >
    swap
    uncover 2
    uncover 2
    select
    // contracts/abstracted_account.algo.ts:382
    // assert(available >= amount, 'Allowance exceeded');
    dup
    dig 2
    >=
    assert // Allowance exceeded
    // contracts/abstracted_account.algo.ts:384
    // const leftover = new UintN64(available - amount)
    swap
    -
    itob
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:387
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:386-390
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: leftover,
    //   last: arc4EpochRef
    // })
    intc_0 // 0
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:387
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:386-390
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: leftover,
    //   last: arc4EpochRef
    // })
    intc_1 // 1
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:387
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:386-390
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: leftover,
    //   last: arc4EpochRef
    // })
    pushint 9 // 9
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:387
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    // contracts/abstracted_account.algo.ts:386-390
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: leftover,
    //   last: arc4EpochRef
    // })
    pushint 25 // 25
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 0
    concat
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig -3
    concat
    // contracts/abstracted_account.algo.ts:386-390
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   ...this.allowances(key).value,
    //   spent: leftover,
    //   last: arc4EpochRef
    // })
    swap
    box_put

verifyAllowance_after_if_else@15:
    b verifyAllowance_after_if_else@16

verifyAllowance_ternary_false@13:
    // contracts/abstracted_account.algo.ts:371
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b verifyAllowance_ternary_merge@14

verifyAllowance_ternary_false@2:
    // contracts/abstracted_account.algo.ts:341
    // : new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    b verifyAllowance_ternary_merge@3


// contracts/abstracted_account.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds: uint64, start: uint64, interval: uint64) -> uint64:
getLatestWindowStart:
    // contracts/abstracted_account.algo.ts:394
    // private getLatestWindowStart(useRounds: boolean, start: uint64, interval: uint64): uint64 {
    proto 3 1

getLatestWindowStart_block@0:
    // contracts/abstracted_account.algo.ts:395
    // if (useRounds) {
    frame_dig -3
    bz getLatestWindowStart_after_if_else@2

getLatestWindowStart_if_body@1:
    // contracts/abstracted_account.algo.ts:396
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig -2
    -
    frame_dig -1
    %
    -
    retsub

getLatestWindowStart_after_if_else@2:
    // contracts/abstracted_account.algo.ts:398
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig -2
    -
    frame_dig -1
    %
    -
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.getAuthAddr() -> bytes:
getAuthAddr:

getAuthAddr_block@0:
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:406
    // return this.spendingAddress.value === this.controlledAddress.value
    ==
    // contracts/abstracted_account.algo.ts:406-410
    // return this.spendingAddress.value === this.controlledAddress.value
    //   ? this.controlledAddress.value === Global.currentApplicationAddress
    //     ? Global.zeroAddress // contract controls itself
    //     : Global.currentApplicationAddress // contract controls a different account
    //   : Global.zeroAddress; // is a spending account
    bz getAuthAddr_ternary_false@5

getAuthAddr_ternary_true@1:
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:407
    // ? this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // contracts/abstracted_account.algo.ts:407-409
    // ? this.controlledAddress.value === Global.currentApplicationAddress
    //   ? Global.zeroAddress // contract controls itself
    //   : Global.currentApplicationAddress // contract controls a different account
    bz getAuthAddr_ternary_false@3

getAuthAddr_ternary_true@2:
    // contracts/abstracted_account.algo.ts:408
    // ? Global.zeroAddress // contract controls itself
    global ZeroAddress

getAuthAddr_ternary_merge@4:
    b getAuthAddr_ternary_merge@6

getAuthAddr_ternary_merge@6:
    // contracts/abstracted_account.algo.ts:406-410
    // return this.spendingAddress.value === this.controlledAddress.value
    //   ? this.controlledAddress.value === Global.currentApplicationAddress
    //     ? Global.zeroAddress // contract controls itself
    //     : Global.currentApplicationAddress // contract controls a different account
    //   : Global.zeroAddress; // is a spending account
    retsub

getAuthAddr_ternary_false@3:
    // contracts/abstracted_account.algo.ts:409
    // : Global.currentApplicationAddress // contract controls a different account
    global CurrentApplicationAddress
    b getAuthAddr_ternary_merge@4

getAuthAddr_ternary_false@5:
    // contracts/abstracted_account.algo.ts:410
    // : Global.zeroAddress; // is a spending account
    global ZeroAddress
    b getAuthAddr_ternary_merge@6


// contracts/abstracted_account.algo.ts::AbstractedAccount.createApplication(controlledAddress: bytes, admin: bytes, spendingAccountFactoryApp: uint64) -> void:
createApplication:
    // contracts/abstracted_account.algo.ts:421-422
    // @abimethod({ onCreate: 'require' })
    // createApplication(controlledAddress: Address, admin: Address, spendingAccountFactoryApp: Application): void {
    proto 3 0

createApplication_block@0:
    // contracts/abstracted_account.algo.ts:424
    // Txn.sender === controlledAddress.native
    txn Sender
    frame_dig -3
    ==
    // contracts/abstracted_account.algo.ts:424-425
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bnz createApplication_bool_true@2

createApplication_or_contd@1:
    // contracts/abstracted_account.algo.ts:425
    // || Txn.sender === admin.native,
    txn Sender
    frame_dig -2
    ==
    // contracts/abstracted_account.algo.ts:424-425
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bz createApplication_bool_false@3

createApplication_bool_true@2:
    intc_1 // 1

createApplication_bool_merge@4:
    // contracts/abstracted_account.algo.ts:423-427
    // assert(
    //   Txn.sender === controlledAddress.native
    //   || Txn.sender === admin.native,
    //   ERR_SENDER_MUST_BE_ADMIN_OR_CONTROLLED_ADDRESS
    // );
    assert // sender must be either controlledAddress or admin
    // contracts/abstracted_account.algo.ts:428
    // assert(admin !== controlledAddress);
    frame_dig -2
    frame_dig -3
    !=
    assert
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 5 // "admin"
    // contracts/abstracted_account.algo.ts:430
    // this.admin.value = admin.native;
    frame_dig -2
    app_global_put
    // contracts/abstracted_account.algo.ts:431
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    global ZeroAddress
    frame_dig -3
    ==
    bz createApplication_ternary_false@6

createApplication_ternary_true@5:
    // contracts/abstracted_account.algo.ts:431
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    global CurrentApplicationAddress

createApplication_ternary_merge@7:
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // contracts/abstracted_account.algo.ts:431
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    swap
    app_global_put
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    bytec 8 // "spend_factory"
    // contracts/abstracted_account.algo.ts:432
    // this.spendingAccountFactoryApp.value = spendingAccountFactoryApp;
    frame_dig -1
    app_global_put
    // contracts/abstracted_account.algo.ts:433
    // this.spendingAddress.value = Global.zeroAddress;
    global ZeroAddress
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 6 // "spending_address"
    // contracts/abstracted_account.algo.ts:433
    // this.spendingAddress.value = Global.zeroAddress;
    swap
    app_global_put
    // contracts/abstracted_account.algo.ts:434
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:435
    // this.updateLastChange()
    callsub updateLastChange
    retsub

createApplication_ternary_false@6:
    // contracts/abstracted_account.algo.ts:431
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    frame_dig -3
    b createApplication_ternary_merge@7

createApplication_bool_false@3:
    intc_0 // 0
    b createApplication_bool_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // contracts/abstracted_account.algo.ts:443
    // arc58_changeAdmin(newAdmin: Address): void {
    proto 1 0

arc58_changeAdmin_block@0:
    // contracts/abstracted_account.algo.ts:444
    // assert(Txn.sender === this.admin.value, ERR_ONLY_ADMIN_CAN_CHANGE_ADMIN);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:444
    // assert(Txn.sender === this.admin.value, ERR_ONLY_ADMIN_CAN_CHANGE_ADMIN);
    ==
    assert // only admin can change the admin account
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 5 // "admin"
    // contracts/abstracted_account.algo.ts:445
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    // contracts/abstracted_account.algo.ts:446
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:447
    // this.updateLastChange()
    callsub updateLastChange
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // contracts/abstracted_account.algo.ts:458
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    proto 3 0

arc58_pluginChangeAdmin_block@0:
    // contracts/abstracted_account.algo.ts:459
    // assert(Txn.sender === Application(plugin).address, ERR_SENDER_MUST_BE_ADMIN_PLUGIN);
    txn Sender
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    assert // sender must be admin plugin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:461
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/abstracted_account.algo.ts:460-463
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // contracts/abstracted_account.algo.ts:466
    // application: new UintN64(plugin),
    frame_dig -3
    itob
    // contracts/abstracted_account.algo.ts:465-468
    // const key = new arc4PluginsKey({
    //   application: new UintN64(plugin),
    //   allowedCaller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -2
    concat
    dup
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/abstracted_account.algo.ts:471
    // this.plugins(key).exists && this.plugins(key).value.admin.native,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@3

arc58_pluginChangeAdmin_and_contd@1:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // contracts/abstracted_account.algo.ts:471
    // this.plugins(key).exists && this.plugins(key).value.admin.native,
    box_get
    assert // Box must have value
    intc_0 // 0
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3

arc58_pluginChangeAdmin_bool_true@2:
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // contracts/abstracted_account.algo.ts:470-473
    // assert(
    //   this.plugins(key).exists && this.plugins(key).value.admin.native,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 5 // "admin"
    // contracts/abstracted_account.algo.ts:475
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // contracts/abstracted_account.algo.ts:476
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    box_get
    assert // Box must have value
    intc_1 // 1
    dup
    extract3 // on error: Index access is out of bounds
    // contracts/types.ts:71
    // export const DelegationTypeSelf = new UintN8(1)
    bytec 11 // 0x01
    // contracts/abstracted_account.algo.ts:476
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    ==
    bz arc58_pluginChangeAdmin_after_if_else@6

arc58_pluginChangeAdmin_if_body@5:
    // contracts/abstracted_account.algo.ts:477
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction

arc58_pluginChangeAdmin_after_if_else@6:
    // contracts/abstracted_account.algo.ts:479
    // this.updateLastChange()
    callsub updateLastChange
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:

arc58_getAdmin_block@0:
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:489
    // return new Address(this.admin.value);
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:

arc58_verifyAuthAddr_block@0:
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:496
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    acct_params_get AcctAuthAddr
    assert // account funded
    callsub getAuthAddr
    ==
    assert
    // contracts/abstracted_account.algo.ts:497
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 6 // "spending_address"
    // contracts/abstracted_account.algo.ts:497
    // this.spendingAddress.value = Global.zeroAddress
    swap
    app_global_put
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: uint64) -> void:
arc58_rekeyTo:
    // contracts/abstracted_account.algo.ts:506
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    proto 2 0

arc58_rekeyTo_block@0:
    // contracts/abstracted_account.algo.ts:507
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:507
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/abstracted_account.algo.ts:509-517
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:512
    // receiver: address.native,
    frame_dig -2
    // contracts/abstracted_account.algo.ts:513
    // rekeyTo: address.native,
    dup
    // contracts/abstracted_account.algo.ts:514
    // note: 'rekeying abstracted account',
    pushbytes "rekeying abstracted account"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:509-516
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:515
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_rekeyTo_next_txn@1:
    // contracts/abstracted_account.algo.ts:509-517
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // contracts/abstracted_account.algo.ts:519
    // if (flash) this.assertRekeysBack();
    frame_dig -1
    bz arc58_rekeyTo_after_if_else@3

arc58_rekeyTo_if_body@2:
    // contracts/abstracted_account.algo.ts:519
    // if (flash) this.assertRekeysBack();
    callsub assertRekeysBack

arc58_rekeyTo_after_if_else@3:
    // contracts/abstracted_account.algo.ts:521
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: uint64, address: bytes, method: bytes) -> uint64:
arc58_canCall:
    // contracts/abstracted_account.algo.ts:532-538
    // @abimethod({ readonly: true })
    // arc58_canCall(
    //   plugin: uint64,
    //   global: boolean,
    //   address: Address,
    //   method: StaticBytes<4>
    // ): boolean {
    proto 4 1

arc58_canCall_block@0:
    // contracts/abstracted_account.algo.ts:539
    // if (global) {
    frame_dig -3
    bz arc58_canCall_after_if_else@2

arc58_canCall_if_body@1:
    // contracts/abstracted_account.algo.ts:540
    // this.pluginCallAllowed(plugin, Global.zeroAddress, method);
    global ZeroAddress
    frame_dig -4
    swap
    frame_dig -1
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@2:
    // contracts/abstracted_account.algo.ts:542
    // return this.pluginCallAllowed(plugin, address.native, method);
    frame_dig -4
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> bytes, bytes:
arc58_rekeyToPlugin:
    // contracts/abstracted_account.algo.ts:554-559
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: DynamicArray<UintN64>,
    //   fundsRequest: DynamicArray<arc4FundsRequest>
    // ): void {
    proto 4 2
    intc_0 // 0
    dupn 2
    bytec_1 // ""

arc58_rekeyToPlugin_block@0:
    frame_dig -2
    frame_dig -1
    // contracts/abstracted_account.algo.ts:560
    // const pluginApp = Application(plugin)
    frame_dig -4
    // contracts/abstracted_account.algo.ts:563
    // application: new UintN64(plugin),
    dup
    itob
    // contracts/abstracted_account.algo.ts:564-566
    // allowedCaller: global
    //   ? new Address(Global.zeroAddress)
    //   : new Address(Txn.sender)
    frame_dig -3
    bz arc58_rekeyToPlugin_ternary_false@2

arc58_rekeyToPlugin_ternary_true@1:
    // contracts/abstracted_account.algo.ts:565
    // ? new Address(Global.zeroAddress)
    global ZeroAddress

arc58_rekeyToPlugin_ternary_merge@3:
    // contracts/abstracted_account.algo.ts:562-567
    // const key = new arc4PluginsKey({
    //   application: new UintN64(plugin),
    //   allowedCaller: global
    //     ? new Address(Global.zeroAddress)
    //     : new Address(Txn.sender)
    // });
    bytec_1 // 0x
    frame_dig 7
    concat
    swap
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:569
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/abstracted_account.algo.ts:571
    // this.assertValidGroup(key, methodOffsets);
    frame_dig -2
    callsub assertValidGroup
    swap
    frame_bury 0
    frame_bury -2
    intc_1 // 1
    bz arc58_rekeyToPlugin_after_if_else@5

arc58_rekeyToPlugin_if_body@4:
    frame_dig -2
    frame_bury 4

arc58_rekeyToPlugin_after_if_else@5:
    // contracts/abstracted_account.algo.ts:571
    // this.assertValidGroup(key, methodOffsets);
    frame_dig 0
    dup
    frame_bury 1
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/abstracted_account.algo.ts:573
    // if (this.plugins(key).value.spendingApp.native !== 0) {
    box_get
    assert // Box must have value
    pushint 2 // 2
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    intc_0 // 0
    !=
    bz arc58_rekeyToPlugin_else_body@10

arc58_rekeyToPlugin_if_body@6:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 1
    dup
    cover 2
    concat
    // contracts/abstracted_account.algo.ts:574
    // const spendingApp = Application(this.plugins(key).value.spendingApp.native)
    box_get
    assert // Box must have value
    pushint 2 // 2
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    dup
    frame_bury 3
    // contracts/abstracted_account.algo.ts:575
    // this.spendingAddress.value = spendingApp.address;
    app_params_get AppAddress
    assert // application exists
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 6 // "spending_address"
    // contracts/abstracted_account.algo.ts:575
    // this.spendingAddress.value = spendingApp.address;
    swap
    app_global_put
    // contracts/abstracted_account.algo.ts:576
    // this.transferFunds(key, fundsRequest);
    frame_dig -1
    callsub transferFunds
    swap
    frame_bury 2
    frame_bury -1
    intc_1 // 1
    bz arc58_rekeyToPlugin_after_if_else@8

arc58_rekeyToPlugin_if_body@7:
    frame_dig -1
    frame_bury 5

arc58_rekeyToPlugin_after_if_else@8:
    // contracts/abstracted_account.algo.ts:576
    // this.transferFunds(key, fundsRequest);
    frame_dig 2
    frame_bury 1
    // contracts/abstracted_account.algo.ts:578-585
    // abiCall(
    //   SpendingAccountContract.prototype.rekey,
    //   {
    //     appId: spendingApp,
    //     args: [new Address(pluginApp.address)],
    //     fee: 0,
    //   }
    // )
    itxn_begin
    // contracts/abstracted_account.algo.ts:581
    // appId: spendingApp,
    frame_dig 3
    // contracts/abstracted_account.algo.ts:582
    // args: [new Address(pluginApp.address)],
    frame_dig 6
    app_params_get AppAddress
    assert // application exists
    // contracts/abstracted_account.algo.ts:578-585
    // abiCall(
    //   SpendingAccountContract.prototype.rekey,
    //   {
    //     appId: spendingApp,
    //     args: [new Address(pluginApp.address)],
    //     fee: 0,
    //   }
    // )
    pushbytes 0x65a97bcc // method "rekey(address)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:583
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_rekeyToPlugin_next_txn@9:
    // contracts/abstracted_account.algo.ts:578-585
    // abiCall(
    //   SpendingAccountContract.prototype.rekey,
    //   {
    //     appId: spendingApp,
    //     args: [new Address(pluginApp.address)],
    //     fee: 0,
    //   }
    // )
    itxn_submit

arc58_rekeyToPlugin_after_if_else@12:
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 1
    concat
    // contracts/abstracted_account.algo.ts:600
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    box_get
    assert // Box must have value
    intc_1 // 1
    dup
    extract3 // on error: Index access is out of bounds
    // contracts/types.ts:71
    // export const DelegationTypeSelf = new UintN8(1)
    bytec 11 // 0x01
    // contracts/abstracted_account.algo.ts:600
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    ==
    bz arc58_rekeyToPlugin_after_if_else@14

arc58_rekeyToPlugin_if_body@13:
    // contracts/abstracted_account.algo.ts:601
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction

arc58_rekeyToPlugin_after_if_else@14:
    frame_dig 4
    frame_dig 5
    frame_bury 1
    frame_bury 0
    retsub

arc58_rekeyToPlugin_else_body@10:
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 6 // "spending_address"
    // contracts/abstracted_account.algo.ts:587
    // this.spendingAddress.value = this.controlledAddress.value;
    swap
    app_global_put
    // contracts/abstracted_account.algo.ts:589-597
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/constants.ts:6
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec 6 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:593
    // rekeyTo: pluginApp.address,
    frame_dig 6
    app_params_get AppAddress
    assert // application exists
    // contracts/abstracted_account.algo.ts:594
    // note: 'rekeying to plugin app',
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:589-596
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:595
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_rekeyToPlugin_next_txn@11:
    // contracts/abstracted_account.algo.ts:589-597
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    b arc58_rekeyToPlugin_after_if_else@12

arc58_rekeyToPlugin_ternary_false@2:
    // contracts/abstracted_account.algo.ts:566
    // : new Address(Txn.sender)
    txn Sender
    b arc58_rekeyToPlugin_ternary_merge@3


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // contracts/abstracted_account.algo.ts:615
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: DynamicArray<UintN64>, fundsRequest: DynamicArray<arc4FundsRequest>): void {
    proto 4 0

arc58_rekeyToNamedPlugin_block@0:
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -4
    concat
    // contracts/abstracted_account.algo.ts:617
    // this.namedPlugins(name).value.application.native,
    box_get
    assert // Box must have value
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    // contracts/abstracted_account.algo.ts:616-621
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.application.native,
    //   global,
    //   methodOffsets,
    //   fundsRequest
    // );
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub arc58_rekeyToPlugin
    popn 2
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: uint64, allowedCaller: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useAllowance: uint64, useRounds: uint64) -> void:
arc58_addPlugin:
    // contracts/abstracted_account.algo.ts:637-647
    // arc58_addPlugin(
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    proto 9 0
    intc_0 // 0
    dupn 2
    bytec_1 // ""
    dup

arc58_addPlugin_block@0:
    // contracts/abstracted_account.algo.ts:648
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:648
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/abstracted_account.algo.ts:650
    // delegationType === DelegationTypeSelf &&
    frame_dig -6
    // contracts/types.ts:71
    // export const DelegationTypeSelf = new UintN8(1)
    bytec 11 // 0x01
    // contracts/abstracted_account.algo.ts:650
    // delegationType === DelegationTypeSelf &&
    ==
    // contracts/abstracted_account.algo.ts:650-651
    // delegationType === DelegationTypeSelf &&
    // allowedCaller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3

arc58_addPlugin_and_contd@1:
    // contracts/abstracted_account.algo.ts:651
    // allowedCaller.native === Global.zeroAddress
    global ZeroAddress
    frame_dig -8
    ==
    // contracts/abstracted_account.algo.ts:650-651
    // delegationType === DelegationTypeSelf &&
    // allowedCaller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3

arc58_addPlugin_bool_true@2:
    intc_1 // 1

arc58_addPlugin_bool_merge@4:
    // contracts/abstracted_account.algo.ts:653
    // assert(!badDelegationCombo, ERR_ZERO_ADDRESS_DELEGATION_TYPE)
    !
    assert // delegation type must not be self for global plugins
    // contracts/abstracted_account.algo.ts:655
    // application: new UintN64(app),
    frame_dig -9
    itob
    // contracts/abstracted_account.algo.ts:654-657
    // const key = new arc4PluginsKey({
    //   application: new UintN64(app),
    //   allowedCaller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -8
    concat
    frame_bury 0
    // contracts/abstracted_account.algo.ts:659
    // let methodInfos = new DynamicArray<arc4MethodInfo>();
    bytec 13 // 0x0000
    bytec_1 // 0x
    concat
    frame_bury 1
    // contracts/abstracted_account.algo.ts:660
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 4

arc58_addPlugin_while_top@5:
    // contracts/abstracted_account.algo.ts:660
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -3
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz arc58_addPlugin_after_while@7

arc58_addPlugin_while_body@6:
    // contracts/abstracted_account.algo.ts:661-665
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    frame_dig 1
    extract 2 0
    // contracts/abstracted_account.algo.ts:662
    // selector: methods[i].selector,
    frame_dig -3
    extract 2 0
    frame_dig 4
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    intc_0 // 0
    intc_3 // 4
    extract3 // on error: Index access is out of bounds
    swap
    // contracts/abstracted_account.algo.ts:663
    // cooldown: methods[i].cooldown,
    frame_dig -3
    extract 2 0
    dig 1
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    intc_3 // 4
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/abstracted_account.algo.ts:661-665
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    bytec_1 // 0x
    uncover 3
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:664
    // lastCalled: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:661-665
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    concat
    bytec_1 // 0x
    swap
    concat
    bytec_1 // 0x
    swap
    concat
    uncover 2
    swap
    concat
    dup
    len
    pushint 20 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // contracts/abstracted_account.algo.ts:660
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 4
    b arc58_addPlugin_while_top@5

arc58_addPlugin_after_while@7:
    // contracts/abstracted_account.algo.ts:668
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -1
    bz arc58_addPlugin_ternary_false@9

arc58_addPlugin_ternary_true@8:
    // contracts/abstracted_account.algo.ts:668
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

arc58_addPlugin_ternary_merge@10:
    // contracts/abstracted_account.algo.ts:668
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_bury 3
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:670
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addPlugin_after_if_else@13

arc58_addPlugin_if_body@11:
    // contracts/abstracted_account.algo.ts:671-678
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:674
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/abstracted_account.algo.ts:675
    // amount: 36_500 + (400 * methods.bytes.length),
    frame_dig -3
    len
    intc 5 // 400
    *
    intc 6 // 36500
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:671-677
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:676
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addPlugin_next_txn@12:
    // contracts/abstracted_account.algo.ts:671-678
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_addPlugin_after_if_else@13:
    // contracts/abstracted_account.algo.ts:681
    // let spendingApp = new UintN64(0)
    bytec 7 // 0x0000000000000000
    frame_bury 2
    // contracts/abstracted_account.algo.ts:682
    // if (useAllowance) {
    frame_dig -2
    bz arc58_addPlugin_after_if_else@17

arc58_addPlugin_if_body@14:
    // contracts/abstracted_account.algo.ts:684-699
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         amount: 269_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       app,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_begin
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:692
    // receiver: this.spendingAccountFactoryApp.value.address,
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    // contracts/abstracted_account.algo.ts:691
    // amount: 269_500,
    pushint 269500 // 269500
    itxn_field Amount
    // contracts/abstracted_account.algo.ts:690-694
    // itxn.payment({
    //   amount: 269_500,
    //   receiver: this.spendingAccountFactoryApp.value.address,
    //   fee: 0,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:693
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addPlugin_next_txn@15:
    // contracts/abstracted_account.algo.ts:684-699
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         amount: 269_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       app,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_next
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:695
    // app,
    frame_dig -9
    itob
    // contracts/abstracted_account.algo.ts:684-699
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         amount: 269_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       app,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    bytec 14 // method "create(pay,uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:697
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addPlugin_next_txn@16:
    // contracts/abstracted_account.algo.ts:684-699
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         amount: 269_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       app,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 10 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // contracts/abstracted_account.algo.ts:683-700
    // spendingApp = new UintN64(
    //   abiCall(
    //     SpendingAccountFactory.prototype.create,
    //     {
    //       sender: this.controlledAddress.value,
    //       appId: this.spendingAccountFactoryApp.value,
    //       args: [
    //         itxn.payment({
    //           amount: 269_500,
    //           receiver: this.spendingAccountFactoryApp.value.address,
    //           fee: 0,
    //         }),
    //         app,
    //       ],
    //       fee: 0,
    //     }
    //   ).returnValue
    // )
    itob
    frame_bury 2

arc58_addPlugin_after_if_else@17:
    // contracts/abstracted_account.algo.ts:704
    // admin: new Bool(admin),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -7
    setbit
    // contracts/abstracted_account.algo.ts:707
    // lastValid: new UintN64(lastValid),
    frame_dig -5
    itob
    swap
    // contracts/abstracted_account.algo.ts:708
    // cooldown: new UintN64(cooldown),
    frame_dig -4
    itob
    cover 2
    // contracts/abstracted_account.algo.ts:709
    // methods: methodInfos.copy(),
    frame_dig 1
    cover 3
    // contracts/abstracted_account.algo.ts:710
    // useAllowance: new Bool(useAllowance),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -2
    setbit
    cover 3
    // contracts/abstracted_account.algo.ts:711
    // useRounds: new Bool(useRounds),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    cover 3
    // contracts/abstracted_account.algo.ts:713
    // start: new UintN64(epochRef),
    frame_dig 3
    itob
    cover 5
    // contracts/abstracted_account.algo.ts:703-714
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef),
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -6
    concat
    frame_dig 2
    concat
    swap
    concat
    swap
    concat
    pushint 45 // 45
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    intc_0 // 0
    getbit
    swap
    intc 4 // 225
    uncover 2
    setbit
    // contracts/abstracted_account.algo.ts:712
    // lastCalled: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:703-714
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef),
    // });
    concat
    swap
    concat
    swap
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // contracts/abstracted_account.algo.ts:703-714
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef),
    // });
    dup
    box_del
    pop
    swap
    box_put
    // contracts/abstracted_account.algo.ts:716
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:717
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_addPlugin_ternary_false@9:
    // contracts/abstracted_account.algo.ts:668
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addPlugin_ternary_merge@10

arc58_addPlugin_bool_false@3:
    intc_0 // 0
    b arc58_addPlugin_bool_merge@4


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: uint64, allowedCaller: bytes) -> void:
arc58_removePlugin:
    // contracts/abstracted_account.algo.ts:728
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    proto 2 0

arc58_removePlugin_block@0:
    // contracts/abstracted_account.algo.ts:729
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:729
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/abstracted_account.algo.ts:732
    // application: new UintN64(app),
    frame_dig -2
    itob
    // contracts/abstracted_account.algo.ts:731-734
    // const key = new arc4PluginsKey({
    //   application: new UintN64(app),
    //   allowedCaller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -1
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:736
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:738
    // const spendingApp = this.plugins(key).value.spendingApp.native;
    box_get
    assert // Box must have value
    pushint 2 // 2
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:739
    // const methods = this.plugins(key).value.methods.copy();
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    swap
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/abstracted_account.algo.ts:741
    // this.plugins(key).delete();
    box_del
    pop
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:743
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removePlugin_after_if_else@3

arc58_removePlugin_if_body@1:
    // contracts/abstracted_account.algo.ts:744-750
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:747
    // amount: 36_500 + (400 * methods.bytes.length),
    frame_dig 1
    len
    intc 5 // 400
    *
    intc 6 // 36500
    +
    itxn_field Amount
    itxn_field Receiver
    // contracts/abstracted_account.algo.ts:744-749
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:748
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_removePlugin_next_txn@2:
    // contracts/abstracted_account.algo.ts:744-750
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 36_500 + (400 * methods.bytes.length),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_removePlugin_after_if_else@3:
    // contracts/abstracted_account.algo.ts:753
    // if (spendingApp !== 0) {
    frame_dig 0
    intc_0 // 0
    !=
    bz arc58_removePlugin_after_if_else@6

arc58_removePlugin_if_body@4:
    // contracts/abstracted_account.algo.ts:754-761
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    itxn_begin
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:758
    // args: [spendingApp],
    frame_dig 0
    itob
    // contracts/abstracted_account.algo.ts:754-761
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    bytec 15 // method "delete(uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:759
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_removePlugin_next_txn@5:
    // contracts/abstracted_account.algo.ts:754-761
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    itxn_submit

arc58_removePlugin_after_if_else@6:
    // contracts/abstracted_account.algo.ts:764
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:765
    // this.updateLastChange();
    callsub updateLastChange
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: uint64, allowedCaller: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useAllowance: uint64, useRounds: uint64) -> void:
arc58_addNamedPlugin:
    // contracts/abstracted_account.algo.ts:782-793
    // arc58_addNamedPlugin(
    //   name: string,
    //   app: uint64,
    //   allowedCaller: Address,
    //   admin: boolean,
    //   delegationType: UintN8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: DynamicArray<arc4MethodRestriction>,
    //   useAllowance: boolean,
    //   useRounds: boolean,
    // ): void {
    proto 10 0
    intc_0 // 0

arc58_addNamedPlugin_block@0:
    // contracts/abstracted_account.algo.ts:794
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:794
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -10
    concat
    // contracts/abstracted_account.algo.ts:795
    // assert(!this.namedPlugins(name).exists);
    box_len
    bury 1
    !
    assert
    // contracts/abstracted_account.algo.ts:798
    // application: new UintN64(app),
    frame_dig -9
    itob
    // contracts/abstracted_account.algo.ts:797-800
    // const key = new arc4PluginsKey({
    //   application: new UintN64(app),
    //   allowedCaller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -8
    concat
    dup
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -10
    concat
    // contracts/abstracted_account.algo.ts:801
    // this.namedPlugins(name).value = key.copy();
    swap
    box_put
    // contracts/abstracted_account.algo.ts:803
    // let methodInfos = new DynamicArray<arc4MethodInfo>();
    bytec 13 // 0x0000
    bytec_1 // 0x
    concat
    // contracts/abstracted_account.algo.ts:804
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0

arc58_addNamedPlugin_while_top@1:
    // contracts/abstracted_account.algo.ts:804
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -3
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz arc58_addNamedPlugin_after_while@3

arc58_addNamedPlugin_while_body@2:
    // contracts/abstracted_account.algo.ts:805-809
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    frame_dig 2
    extract 2 0
    // contracts/abstracted_account.algo.ts:806
    // selector: methods[i].selector,
    frame_dig -3
    extract 2 0
    frame_dig 3
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    intc_0 // 0
    intc_3 // 4
    extract3 // on error: Index access is out of bounds
    swap
    // contracts/abstracted_account.algo.ts:807
    // cooldown: methods[i].cooldown,
    frame_dig -3
    extract 2 0
    dig 1
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    intc_3 // 4
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // contracts/abstracted_account.algo.ts:805-809
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    bytec_1 // 0x
    uncover 3
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:808
    // lastCalled: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:805-809
    // methodInfos.push(new arc4MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new UintN64(0),
    // }));
    concat
    bytec_1 // 0x
    swap
    concat
    bytec_1 // 0x
    swap
    concat
    uncover 2
    swap
    concat
    dup
    len
    pushint 20 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 2
    // contracts/abstracted_account.algo.ts:804
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 3
    b arc58_addNamedPlugin_while_top@1

arc58_addNamedPlugin_after_while@3:
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:812
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addNamedPlugin_after_if_else@6

arc58_addNamedPlugin_if_body@4:
    // contracts/abstracted_account.algo.ts:813-820
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:816
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/abstracted_account.algo.ts:817
    // amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    frame_dig -3
    len
    frame_dig -10
    len
    +
    intc 5 // 400
    *
    intc 7 // 55400
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:813-819
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:818
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addNamedPlugin_next_txn@5:
    // contracts/abstracted_account.algo.ts:813-820
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_addNamedPlugin_after_if_else@6:
    // contracts/abstracted_account.algo.ts:823
    // let spendingApp = new UintN64(0)
    bytec 7 // 0x0000000000000000
    frame_bury 0
    // contracts/abstracted_account.algo.ts:824
    // if (useAllowance) {
    frame_dig -2
    bz arc58_addNamedPlugin_after_if_else@10

arc58_addNamedPlugin_if_body@7:
    // contracts/abstracted_account.algo.ts:826-841
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: 12_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       0,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:834
    // receiver: this.spendingAccountFactoryApp.value.address,
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    // contracts/abstracted_account.algo.ts:833
    // amount: 12_500,
    pushint 12500 // 12500
    itxn_field Amount
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:831-836
    // itxn.payment({
    //   sender: this.controlledAddress.value,
    //   amount: 12_500,
    //   receiver: this.spendingAccountFactoryApp.value.address,
    //   fee: 0,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:835
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addNamedPlugin_next_txn@8:
    // contracts/abstracted_account.algo.ts:826-841
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: 12_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       0,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_next
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:837
    // 0,
    intc_0 // 0
    itob
    // contracts/abstracted_account.algo.ts:826-841
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: 12_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       0,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    bytec 14 // method "create(pay,uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:839
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addNamedPlugin_next_txn@9:
    // contracts/abstracted_account.algo.ts:826-841
    // abiCall(
    //   SpendingAccountFactory.prototype.create,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: 12_500,
    //         receiver: this.spendingAccountFactoryApp.value.address,
    //         fee: 0,
    //       }),
    //       0,
    //     ],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 10 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // contracts/abstracted_account.algo.ts:825-842
    // spendingApp = new UintN64(
    //   abiCall(
    //     SpendingAccountFactory.prototype.create,
    //     {
    //       appId: this.spendingAccountFactoryApp.value,
    //       args: [
    //         itxn.payment({
    //           sender: this.controlledAddress.value,
    //           amount: 12_500,
    //           receiver: this.spendingAccountFactoryApp.value.address,
    //           fee: 0,
    //         }),
    //         0,
    //       ],
    //       fee: 0,
    //     }
    //   ).returnValue
    // )
    itob
    frame_bury 0

arc58_addNamedPlugin_after_if_else@10:
    // contracts/abstracted_account.algo.ts:845
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -1
    bz arc58_addNamedPlugin_ternary_false@12

arc58_addNamedPlugin_ternary_true@11:
    // contracts/abstracted_account.algo.ts:845
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

arc58_addNamedPlugin_ternary_merge@13:
    // contracts/abstracted_account.algo.ts:848
    // admin: new Bool(admin),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -7
    setbit
    // contracts/abstracted_account.algo.ts:851
    // lastValid: new UintN64(lastValid),
    frame_dig -5
    itob
    cover 2
    // contracts/abstracted_account.algo.ts:852
    // cooldown: new UintN64(cooldown),
    frame_dig -4
    itob
    cover 3
    // contracts/abstracted_account.algo.ts:853
    // methods: methodInfos.copy(),
    frame_dig 2
    cover 4
    // contracts/abstracted_account.algo.ts:854
    // useAllowance: new Bool(useAllowance),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -2
    setbit
    cover 4
    // contracts/abstracted_account.algo.ts:855
    // useRounds: new Bool(useRounds),
    bytec 4 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    cover 4
    // contracts/abstracted_account.algo.ts:857
    // start: new UintN64(epochRef)
    swap
    itob
    cover 5
    // contracts/abstracted_account.algo.ts:847-858
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef)
    // })
    bytec_1 // 0x
    swap
    concat
    frame_dig -6
    concat
    frame_dig 0
    concat
    swap
    concat
    swap
    concat
    pushint 45 // 45
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    intc_0 // 0
    getbit
    swap
    intc 4 // 225
    uncover 2
    setbit
    // contracts/abstracted_account.algo.ts:856
    // lastCalled: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:847-858
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef)
    // })
    concat
    swap
    concat
    swap
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 1
    concat
    // contracts/abstracted_account.algo.ts:847-858
    // this.plugins(key).value = new arc4PluginInfo({
    //   admin: new Bool(admin),
    //   delegationType,
    //   spendingApp,
    //   lastValid: new UintN64(lastValid),
    //   cooldown: new UintN64(cooldown),
    //   methods: methodInfos.copy(),
    //   useAllowance: new Bool(useAllowance),
    //   useRounds: new Bool(useRounds),
    //   lastCalled: new UintN64(0),
    //   start: new UintN64(epochRef)
    // })
    dup
    box_del
    pop
    swap
    box_put
    // contracts/abstracted_account.algo.ts:860
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:861
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_addNamedPlugin_ternary_false@12:
    // contracts/abstracted_account.algo.ts:845
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addNamedPlugin_ternary_merge@13


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // contracts/abstracted_account.algo.ts:869
    // arc58_removeNamedPlugin(name: string): void {
    proto 1 0

arc58_removeNamedPlugin_block@0:
    // contracts/abstracted_account.algo.ts:870
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:870
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:871
    // assert(this.namedPlugins(name).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:872
    // const app = this.namedPlugins(name).value.copy();
    box_get
    assert // Box must have value
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:873
    // assert(this.plugins(app).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:875
    // const spendingApp = this.plugins(app).value.spendingApp.native;
    box_get
    assert // Box must have value
    pushint 2 // 2
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:876
    // const methods = this.plugins(app).value.methods.copy();
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    swap
    // contracts/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 9 // "n"
    frame_dig -1
    concat
    // contracts/abstracted_account.algo.ts:878
    // this.namedPlugins(name).delete();
    box_del
    pop
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/abstracted_account.algo.ts:879
    // this.plugins(app).delete();
    box_del
    pop
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:881
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeNamedPlugin_after_if_else@3

arc58_removeNamedPlugin_if_body@1:
    // contracts/abstracted_account.algo.ts:882-888
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:885
    // amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    frame_dig 1
    len
    frame_dig -1
    len
    +
    intc 5 // 400
    *
    intc 7 // 55400
    +
    itxn_field Amount
    itxn_field Receiver
    // contracts/abstracted_account.algo.ts:882-887
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:886
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_removeNamedPlugin_next_txn@2:
    // contracts/abstracted_account.algo.ts:882-888
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 55_400 + (400 * (methods.bytes.length + Bytes(name).length)),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_removeNamedPlugin_after_if_else@3:
    // contracts/abstracted_account.algo.ts:891
    // if (spendingApp !== 0) {
    frame_dig 0
    intc_0 // 0
    !=
    bz arc58_removeNamedPlugin_after_if_else@6

arc58_removeNamedPlugin_if_body@4:
    // contracts/abstracted_account.algo.ts:892-899
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    itxn_begin
    // contracts/constants.ts:5
    // export const AbstractAccountGlobalStateKeysSpendingAccountFactoryApp = 'spend_factory'
    intc_0 // 0
    bytec 8 // "spend_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:896
    // args: [spendingApp],
    frame_dig 0
    itob
    // contracts/abstracted_account.algo.ts:892-899
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    bytec 15 // method "delete(uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:897
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_removeNamedPlugin_next_txn@5:
    // contracts/abstracted_account.algo.ts:892-899
    // abiCall(
    //   SpendingAccountFactory.prototype.delete,
    //   {
    //     appId: this.spendingAccountFactoryApp.value,
    //     args: [spendingApp],
    //     fee: 0,
    //   }
    // )
    itxn_submit

arc58_removeNamedPlugin_after_if_else@6:
    // contracts/abstracted_account.algo.ts:902
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:903
    // this.updateLastChange();
    callsub updateLastChange
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_addAllowance(plugin: uint64, caller: bytes, asset: uint64, type: bytes, allowed: uint64, max: uint64, interval: uint64) -> void:
arc58_addAllowance:
    // contracts/abstracted_account.algo.ts:906-914
    // arc58_addAllowance(
    //   plugin: uint64,
    //   caller: Address,
    //   asset: uint64,
    //   type: SpendAllowanceType,
    //   allowed: uint64,
    //   max: uint64,
    //   interval: uint64,
    // ): void {
    proto 7 0

arc58_addAllowance_block@0:
    // contracts/abstracted_account.algo.ts:915
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:915
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/abstracted_account.algo.ts:918
    // application: new UintN64(plugin),
    frame_dig -7
    itob
    // contracts/abstracted_account.algo.ts:917-920
    // const pkey = new arc4PluginsKey({
    //   application: new UintN64(plugin),
    //   allowedCaller: caller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -6
    concat
    // contracts/abstracted_account.algo.ts:924
    // asset: new UintN64(asset)
    frame_dig -5
    itob
    swap
    // contracts/abstracted_account.algo.ts:922-925
    // const key = new arc4AllowanceKey({
    //   ...pkey,
    //   asset: new UintN64(asset)
    // });
    dup
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    swap
    dup
    intc_2 // 8
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x
    uncover 3
    concat
    swap
    concat
    uncover 2
    concat
    dup
    cover 2
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    uncover 2
    concat
    // contracts/abstracted_account.algo.ts:927
    // assert(this.plugins(pkey).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    swap
    concat
    // contracts/abstracted_account.algo.ts:928
    // assert(!this.allowances(key).exists, ERR_ALLOWANCE_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // allowance already exists
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:930
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addAllowance_after_if_else@3

arc58_addAllowance_if_body@1:
    // contracts/abstracted_account.algo.ts:931-938
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:934
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/abstracted_account.algo.ts:935
    // amount: 38_500,
    intc 8 // 38500
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // contracts/abstracted_account.algo.ts:931-937
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:936
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_addAllowance_next_txn@2:
    // contracts/abstracted_account.algo.ts:931-938
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_addAllowance_after_if_else@3:
    // contracts/abstracted_account.algo.ts:944
    // allowed: new UintN64(allowed),
    frame_dig -3
    itob
    // contracts/abstracted_account.algo.ts:946
    // max: new UintN64(max),
    frame_dig -2
    itob
    // contracts/abstracted_account.algo.ts:947
    // interval: new UintN64(interval),
    frame_dig -1
    itob
    cover 2
    // contracts/abstracted_account.algo.ts:941-948
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   type,
    //   spent: new UintN64(0),
    //   allowed: new UintN64(allowed),
    //   last: new UintN64(0),
    //   max: new UintN64(max),
    //   interval: new UintN64(interval),
    // });
    bytec_1 // 0x
    frame_dig -4
    concat
    swap
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:943
    // spent: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:941-948
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   type,
    //   spent: new UintN64(0),
    //   allowed: new UintN64(allowed),
    //   last: new UintN64(0),
    //   max: new UintN64(max),
    //   interval: new UintN64(interval),
    // });
    concat
    swap
    concat
    // contracts/abstracted_account.algo.ts:945
    // last: new UintN64(0),
    bytec 7 // 0x0000000000000000
    // contracts/abstracted_account.algo.ts:941-948
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   type,
    //   spent: new UintN64(0),
    //   allowed: new UintN64(allowed),
    //   last: new UintN64(0),
    //   max: new UintN64(max),
    //   interval: new UintN64(interval),
    // });
    concat
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    frame_dig 0
    concat
    // contracts/abstracted_account.algo.ts:941-948
    // this.allowances(key).value = new arc4AllowanceInfo({
    //   type,
    //   spent: new UintN64(0),
    //   allowed: new UintN64(allowed),
    //   last: new UintN64(0),
    //   max: new UintN64(max),
    //   interval: new UintN64(interval),
    // });
    swap
    box_put
    // contracts/abstracted_account.algo.ts:950
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:951
    // this.updateLastChange();
    callsub updateLastChange
    retsub


// contracts/abstracted_account.algo.ts::AbstractedAccount.arc58_removeAllowance(plugin: uint64, caller: bytes, asset: uint64) -> void:
arc58_removeAllowance:
    // contracts/abstracted_account.algo.ts:954
    // arc58_removeAllowance(plugin: uint64, caller: Address, asset: uint64): void {
    proto 3 0

arc58_removeAllowance_block@0:
    // contracts/abstracted_account.algo.ts:955
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // contracts/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:955
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // contracts/abstracted_account.algo.ts:958
    // application: new UintN64(plugin),
    frame_dig -3
    itob
    // contracts/abstracted_account.algo.ts:957-960
    // const pkey = new arc4PluginsKey({
    //   application: new UintN64(plugin),
    //   allowedCaller: caller
    // });
    bytec_1 // 0x
    swap
    concat
    frame_dig -2
    concat
    // contracts/abstracted_account.algo.ts:964
    // asset: new UintN64(asset)
    frame_dig -1
    itob
    swap
    // contracts/abstracted_account.algo.ts:962-965
    // const key = new arc4AllowanceKey({
    //   ...pkey,
    //   asset: new UintN64(asset)
    // });
    dup
    intc_0 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    swap
    dup
    intc_2 // 8
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x
    uncover 3
    concat
    swap
    concat
    uncover 2
    concat
    // contracts/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    uncover 2
    concat
    // contracts/abstracted_account.algo.ts:967
    // assert(this.plugins(pkey).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    dig 1
    concat
    // contracts/abstracted_account.algo.ts:968
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // allowance does not exist
    // contracts/constants.ts:11
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    bytec_3 // "a"
    swap
    concat
    // contracts/abstracted_account.algo.ts:970
    // this.allowances(key).delete();
    box_del
    pop
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:972
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeAllowance_after_if_else@3

arc58_removeAllowance_if_body@1:
    // contracts/abstracted_account.algo.ts:973-979
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/abstracted_account.algo.ts:976
    // amount: 38_500,
    intc 8 // 38500
    itxn_field Amount
    itxn_field Receiver
    // contracts/abstracted_account.algo.ts:973-978
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/abstracted_account.algo.ts:977
    // fee: 0,
    intc_0 // 0
    itxn_field Fee

arc58_removeAllowance_next_txn@2:
    // contracts/abstracted_account.algo.ts:973-979
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: 38_500,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

arc58_removeAllowance_after_if_else@3:
    // contracts/abstracted_account.algo.ts:982
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // contracts/abstracted_account.algo.ts:983
    // this.updateLastChange();
    callsub updateLastChange
    retsub
